/*
 * WARNING: This file is autogenerated by SpaceCommander
 *
 * Any changes will be overwritten!
 */
<%
type_map = { 'char': 'char',
             'int8': 'char',
             'uint8': 'unsigned char',
             'int16': 'int',
             'uint16': 'unsigned int',
             'int32': 'long',
             'uint32': 'unsigned long',
        'float': 'float' }
%>
#ifndef SPACECOMMANDS_HPP
#define SPACECOMMANDS_HPP

## TODO: replace arduino commands  with avr
#include <Arduino.h>

namespace spcmds {

///////////////////////////////////////////////
// Implement these commands in a source file //
///////////////////////////////////////////////
<%
print('\n-----------------------------------------------------')
print('Implement the following functions in your device code')
print('-----------------------------------------------------')
print('\nnamespace spcmds {\n')
%>
% for command in commands:

/**
 *  ${command['description']}
 *
% for input_arg in command['inputs']:
 * @param in_${input_arg['name']} ${input_arg['description']}
% endfor
 *
% for output_arg in command['outputs']:
 * @param out_${output_arg['name']} ${output_arg['description']}
% endfor
 */
<%
cmd_str = 'void {}_callback('.format(command['name'])
for idx, input_arg in enumerate(command['inputs']):
    cmd_str += '{} in_{}'.format(type_map[input_arg['type']], input_arg['name'])
    if idx < len(command['inputs']) - 1 or len(command['outputs']) > 0:
        cmd_str += ', '
for idx, output_arg in enumerate(command['outputs']):
    cmd_str += '{}& out_{}'.format(type_map[output_arg['type']], output_arg['name'])
    if idx < len(command['outputs']) - 1:
        cmd_str += ', '
cmd_str += ')'
print('{} {{\n  // Your code here\n}}\n'.format(cmd_str))
%>
void ${command['name']}_callback(\
% for idx, input_arg in enumerate(command['inputs']):
${type_map[input_arg['type']]} in_${input_arg['name']}\
% if idx < len(command['inputs']) - 1 or len(command['outputs']) > 0:
, \
% endif
% endfor
% for idx, output_arg in enumerate(command['outputs']):
${type_map[output_arg['type']]}& out_${output_arg['name']}\
% if idx < len(command['outputs']) - 1:
, \
% endif
% endfor
);
% endfor

<%
print('} // namespace spcmds\n\n')
%>

////////////////////////
// GENERATED COMMANDS //
////////////////////////

enum commands {
    % for command in commands:
    ${command['name'].upper()},
    % endfor
};

void init() {
    Serial.begin(${device_config['baudrate']});
}

/**
 * Checks for latest incoming messages
 *
 * @return whether a command was called
 */
## TODO: should this return the command enum?
bool process_commands();

//////////////
// INTERNAL //
//////////////

void read_char(char& v) {
    Serial.readBytes(&v, 1);
}

void write_char(char v) {
    Serial.write(v);
}

namespace _internal_ {

% for command in commands:
% if len(command['inputs']) > 0:
struct S_in_${command['name']} {
    % for input_arg in command['inputs']:
    ${type_map[input_arg['type']]} ${input_arg['name']};
    % endfor
};

void read_${command['name']}(S_in_${command['name']}& vals) {
    Serial.readBytes((char*) &vals, sizeof(vals));
}
% endif

%if len(command['outputs']) > 0:
struct S_out_${command['name']} {
    % for output_arg in command['outputs']:
    ${type_map[output_arg['type']]} ${output_arg['name']};
    % endfor
};

void write_${command['name']}(const S_out_${command['name']}& vals) {
    Serial.write((const char*) &vals, sizeof(vals));
}
% endif

% endfor
} // namespace _internal_
    
bool process_commands() {
    if (Serial.available() > 0) {
        char cmd_byte = Serial.read();
        switch(cmd_byte) {
        % for command in commands:
        case ${command['name'].upper()}:
            {
                % if len(command['inputs']) > 0:
                _internal_::S_in_${command['name']} input_vals;
                _internal_::read_${command['name']}(input_vals);
                % endif
                % if len(command['outputs']) > 0:
                _internal_::S_out_${command['name']} output_vals;
                % endif
                ${command['name']}_callback(
                    % for idx, input_arg in enumerate(command['inputs']):
                    input_vals.${input_arg['name']}\
                    % if idx < len(command['inputs']) - 1 or len(command['outputs']) > 0:
,\
                    % endif

                    % endfor
                    % for idx, output_arg in enumerate(command['outputs']):
                    output_vals.${output_arg['name']}\
                    % if idx < len(command['outputs']) - 1:
,\
                    % endif

                    % endfor
                );
                % if len(command['outputs']) > 0:
                _internal_::write_${command['name']}(output_vals);
                % endif
            }
            break;
        % endfor
        default:
            return false;
        }
        return true;
    }
    return false;
}

} // namespace spcmds

#endif // SPACECOMMANDS_HPP
