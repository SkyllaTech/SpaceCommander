<%
    import struct
    type_map = {
        'char': 'c',
        'int8': 'b',
        'uint8': 'B',
        'int16': 'h',
        'uint16':  'H',
        'int32': 'i',
        'uint32': 'I',
        'int64': 'q',
        'uint64': 'Q',
        'float': 'f',
        'string': 'p'
    }
    
    parity_map = {
        'none': 'serial.PARITY_NONE',
        'even': 'serial.PARITY_EVEN',
        'odd': 'serial.PARITY_ODD',
    }

    heartbeat_map = {
        'uint8': 8,
        'uint16': 16,
        'uint32': 32,
        'uint64': 64
    }

    crc_map = {
        'crc-8': 'crc-8',
        'crc-16': 'crc-16',
        'crc-32': 'crc-32',
        'crc-64': 'crc-64'
    }

    crc_size_map = {
        'crc-8': 'B',
        'crc-16': 'H',
        'crc-32': 'I',
        'crc-64': 'Q'
    }

    sof = '0x66'
    eof = '0x99'
    esc = '0xbd'
%>
'''
 WARNING: This file is autogenerated by SpaceCommander

 Any changes will be overwritten!
'''

import struct
import serial
import time
from enum import Enum
% if connection['crc'] != 'none':
import crcmod.predefined
crc_func = crcmod.predefined.mkCrcFun('${crc_map[connection['crc']]}')
crc_format = '${crc_size_map[connection['crc']]}'
crc_size = struct.calcsize(crc_format)
% endif
# Command format
command_format = 'B'
command_size = struct.calcsize(command_format)
# Ack format
ack_format = '?'
ack_size = struct.calcsize(ack_format)
% if connection['addressable']:
# Address format
address_format = 'B'
address_size = struct.calcsize(address_format)
% endif


class COMMANDS(Enum):
    % if heartbeat is not None:
    ${heartbeat['NAME']} = ${heartbeat['index']}
    % endif
    ${connection['hash_name']} = ${connection['hash_index']}
    % for command in commands:
    ${command['NAME']} = ${command['index']}
    % endfor


class MasterBase:
    def __init__(self, port):
        self._ser = serial.serial_for_url(port,
                                          baudrate=${connection['speed']},
                                          parity=${parity_map[connection['parity']]},
                                          % if 'timeout' in master:
                                          timeout=(${master['timeout']} / 1000),
                                          % endif
                                          do_not_open=True)

    # User functions
    # --------------------------------------------------
    def begin(self):
        self._ser.open()
        % if not connection['addressable']:
        if not self.test_hash():
            self._ser.close()
        % endif

    def close(self):
        self._ser.close()

    def test_hash(self\
% if connection['addressable']:
, address\
% endif
):
        hash_val = self._hash_command(\
% if connection['addressable']:
address\
% endif
)
        if hash_val != 0x${connection['hash']}:
            print('Hash Mismatch! Received hash {} but expected {}. Ensure both host and device are the same version.'.format(hex(hash_val), b'${connection['hash']}'.upper()))
            return False
        return True

    def get_hash(self\
% if connection['addressable']:
, address\
% endif
):
        return self._hash_command(\
% if connection['addressable']:
address\
% endif
)

    # Callbacks
    # --------------------------------------------------
    # Callback called before initiating a write to a slave
    def pre_write_cb(self):
        pass

    # Callback called after finishing a write to a slave
    def post_write_cb(self):
        pass

    # Callback called before initiating a read from a slave
    def pre_read_cb(self):
        pass

    # Callback called after finishing a read from a slave
    def post_read_cb(self):
        pass

    # Callback called when no response is received
    def read_no_response_cb(self):
        pass

    % if connection['addressable']:
    # Callback called when the address in the response does not match
    def read_address_mismatch_cb(self):
        pass

    % endif
    # Callback called when a read size fails
    def read_size_fail_cb(self):
        pass

    # Callback called when a CRC fails
    def read_crc_fail_cb(self):
        pass

    # Callback called when a NACK is received
    def read_nack_cb(self):
        pass

    # Commands
    # --------------------------------------------------
    % for command in commands:
    def ${command['name']}(self\
% if connection['addressable']:
, address\
% endif
% for input_arg in command['inputs']:
, ${input_arg['name']}\
% endfor                          
):
        """
        ${command['description']}
        % if len(command['inputs']) > 0:

        Arguments:
        % if connection['addressable']:
        address -- Slave address
        % endif
        % for input in command['inputs']:
        ${input['name']} (${input['type']}) -- ${input['description']}
        % endfor
        % endif
        % if len(command['outputs']) > 0:

        Returns:
        % for output in command['outputs']:
        ${output['name']} (${output['type']}) -- ${output['description']}
        % endfor
        % endif
        """
        self._write_packet(\
% if connection['addressable']:
address, \
% endif
COMMANDS.${command['NAME']}, '${''.join([type_map[i['type']] for i in command['inputs']])}'\
% for input_arg in command['inputs']:
% if input_arg['type'] == 'char':
, ${input_arg['name']}.encode('ascii')\
% else:
, ${input_arg['name']}\
% endif
% endfor
)
        ret_read = self._read_packet(\
% if connection['addressable']:
address, \
% endif
'${''.join([type_map[o['type']] for o in command['outputs']])}')
        % if len(command['outputs']) > 0:
        if ret_read[0]:
            return ret_read[1]\
% if len(command['outputs']) == 1:
[0]\
% endif

        else:
            return None
        % endif

    % endfor
    # Internal functions
    # --------------------------------------------------
    # Add start and end to frame and escape any framing bytes
    def _frame_packet(self, packet_buffer):
        frame = bytearray(0)
        frame.append(${sof})  # Start of frame
        for byte in packet_buffer:
            if byte == ${sof} or byte == ${eof} or byte == ${esc}:  # Escape any framing bytes
                new_byte = byte ^ ${esc}
                frame.append(${esc})
                frame.append(new_byte)
            else:
                frame.append(byte)  # Append normal bytes
        frame.append(${eof})  # End of frame
        return frame

    # Unescape framing bytes and remove end of frame (start of frame should already be removed from buffer)
    def _unframe_packet(self, frame_buffer):
        packet = bytearray(0)
        index = 0
        byte = frame_buffer[index]
        while byte != ${eof} and index < len(frame_buffer) - 1:
            if byte == ${esc}:  # Unescape any framing bytes
                index += 1
                byte = frame_buffer[index]
                new_byte = byte ^ ${esc}
                packet.append(new_byte)
            else:
                packet.append(byte)  # Append normal bytes
            index += 1
            byte = frame_buffer[index]

        if byte != ${eof}:  # Check for end of frame
            return bytearray(0)

        return packet

    def _write_packet(self\
% if connection['addressable']:
, address\
% endif
, command_name, data_format, *data):
        # Pre write callback
        self.pre_write_cb()
        
        # Full packet format string
        packet_format = ''.join(['<'\
% if connection['addressable']:
, address_format\
% endif
, command_format, data_format\
% if connection['crc'] != 'none':
, crc_format\
% endif
])
        # Packet buffer
        packet_size = struct.calcsize(packet_format)
        packet_buffer = bytearray(packet_size)

        % if connection['addressable']:
        # Pack address
        struct.pack_into('<' + address_format, packet_buffer, 0, address)
        % endif
        # Pack command
        struct.pack_into('<' + command_format, packet_buffer, 0\
% if connection['addressable']:
 + address_size\
% endif
, command_name.value)
        # Pack data
        struct.pack_into('<' + data_format, packet_buffer, command_size\
% if connection['addressable']:
 + address_size\
% endif
, *data)
        % if connection['crc'] != 'none':
        # Calculate CRC
        crc = crc_func(packet_buffer[0:(packet_size - crc_size)]) # CRC is always last bytes
        struct.pack_into('<' + crc_format, packet_buffer, (packet_size - crc_size), crc)
        % endif

        # Put packet into a frame
        frame_buffer = self._frame_packet(packet_buffer)
        # print("Write")
        # print(packet_buffer.hex())
        # print(frame_buffer.hex())
        # Write buffer to serial
        self._ser.write(frame_buffer)
        # Post write callback
        self.post_write_cb()

    def _read_packet(self\
% if connection['addressable']:
, address\
% endif
, data_format):
        # Pre read callback
        self.pre_read_cb()
        # Full packet format string
        packet_format = ''.join(['<'\
% if connection['addressable']:
, address_format\
% endif
, ack_format, data_format\
% if connection['crc'] != 'none':
, crc_format\
% endif
])
        # Read frame
        # Discard any bytes received before a Start of Frame
        discard = self._ser.read_until(bytes([${sof}]))
        frame_buffer = self._ser.read_until(bytes([${eof}]))
        
        if len(frame_buffer) < 1:
            print("No response!")
            self.read_no_response_cb()
            return False, None
        
        packet_buffer = self._unframe_packet(frame_buffer)

        # print("Read")
        # print(frame_buffer.hex())
        # print(packet_buffer.hex())
        
        # Packet sizes
        packet_size = struct.calcsize(packet_format)
        data_size = packet_size\
% if connection['addressable']:
 - address_size\
% endif
 - ack_size\
% if connection['crc'] != 'none':
 - crc_size
% endif

        % if connection['addressable']:
        # Unpack address
        sent_address = struct.unpack_from('<' + address_format, packet_buffer, 0)[0]
        if sent_address != address:
            print("Packet address does not match!")
            self.read_address_mismatch_cb()
            return False, None
        
        % endif
        # Unpack ACK
        ack = struct.unpack_from('<' + ack_format, packet_buffer, 0\
% if connection['addressable']:
 + address_size\
% endif
)
        if not ack[0]:
            print("Packet NACK'd!")
            self.read_nack_cb()
            return False, None

        # Read failed either due to timeout or transmission error
        if len(packet_buffer) != packet_size:
            print("Packet read size failed!")
            self.read_size_fail_cb()
            return False, None

        % if connection['crc'] != 'none':
        # Unpack CRC and test
        sent_crc = struct.unpack_from('<' + crc_format, packet_buffer, (packet_size - crc_size))[0]
        calc_crc = crc_func(packet_buffer[0:(packet_size - crc_size)]) # CRC is always last bytes
        # print(hex(sent_crc))
        # print(hex(calc_crc))
        if sent_crc != calc_crc:
            print("Packet CRC failed!")
            self.read_crc_fail_cb()
            return False, None

        % endif
        # Unpack data
        data = struct.unpack_from('<' + data_format, packet_buffer, ack_size\
% if connection['addressable']:
 + address_size\
% endif
)
        # Post read callback
        self.post_read_cb()
        return True, data

    def _hash_command(self\
% if connection['addressable']:
, address\
% endif
):
        self._write_packet(\
% if connection['addressable']:
address, \
% endif
COMMANDS.${connection['hash_name']}, '')
        ret_read = self._read_packet(\
% if connection['addressable']:
address, \
% endif
'Q')
        if ret_read[0]:
            return ret_read[1][0]
        else:
            return 0
