<%
    import struct
    type_map = {
        'char': 'c',
        'int8': 'b',
        'uint8': 'B',
        'int16': 'h',
        'uint16':  'H',
        'int32': 'i',
        'uint32': 'I',
        'int64': 'q',
        'uint64': 'Q',
        'float': 'f',
        'string': 'p'
    }
    
    parity_map = {
        'none': 'serial.PARITY_NONE',
        'even': 'serial.PARITY_EVEN',
        'odd': 'serial.PARITY_ODD',
    }

    heartbeat_map = {
        'uint8': 8,
        'uint16': 16,
        'uint32': 32,
        'uint64': 64
    }
    crc_map = {
        'crc-8': 'crc-8',
        'crc-16': 'crc-16',
        'crc-32': 'crc-32',
        'crc-64': 'crc-64'
    }

    crc_size_map = {
        'crc-8': 'B',
        'crc-16': 'H',
        'crc-32': 'I',
        'crc-64': 'Q'
    }
%>
'''
 WARNING: This file is autogenerated by SpaceCommander

 Any changes will be overwritten!
'''

import struct
import serial
import time
from enum import Enum
% if connection['crc'] != 'none':
import crcmod.predefined
crc_func = crcmod.predefined.mkCrcFun('${crc_map[connection['crc']]}')
crc_format = '${crc_size_map[connection['crc']]}'
crc_size = struct.calcsize(crc_format)
% endif
# Command format
command_format = 'B'
command_size = struct.calcsize(command_format)
# Ack format
ack_format = '?'
ack_size = struct.calcsize(ack_format)
% if connection['addressable']:
# Address format
address_format = 'B'
address_size = struct.calcsize(address_format)
% endif

class COMMANDS(Enum):
    % if heartbeat is not None:
    ${heartbeat['NAME']} = ${heartbeat['index']}
    % endif
    ${connection['hash_name']} = ${connection['hash_index']}
    % for command in commands:
    ${command['NAME']} = ${command['index']}
    % endfor


class SlaveBase:
    def __init__(self, port\
% if connection['addressable']:
, address\
% endif
):
        self._ser = serial.serial_for_url(port,
                                          baudrate=${connection['speed']},
                                          parity=${parity_map[connection['parity']]},
                                          % if 'timeout' in slave:
                                          timeout=(${slave['timeout']} / 1000),
                                          % endif
                                          do_not_open=True)
        % if connection['addressable']:
        self.address = address
        % endif
        self._commands = {
            % if heartbeat is not None:
            COMMANDS.${heartbeat['NAME']}: self._heartbeat_command,
            % endif
            COMMANDS.${connection['hash_name']}: self._hash_command,
            % for command in commands:
            COMMANDS.${command['NAME']}: self._${command['name']},
            % endfor
        }
        % if heartbeat is not None:
        self._heartbeat_count = 0
        self._heartbeat_max = 1 << ${heartbeat_map[heartbeat['size']]}
        % endif

    # User functions
    # --------------------------------------------------
    def begin(self):
        self._ser.open()

    def close(self):
        self._ser.close()

    def process_commands(self):
        if self._ser.in_waiting > 0:
            % if connection['addressable']:
            address_byte = self._ser.read(address_size)
            address = struct.unpack('<' + address_format, address_byte)[0]
            if address != self.address:
                # Wait until we stop receiving bytes to start reading again
                time.sleep(2 * 8 / ${connection['speed']})
                while self._ser.in_waiting > 0:
                    # Dump input buffer
                    self._ser.reset_input_buffer()
                    time.sleep(2 * 8 / ${connection['speed']})
                # Dump input buffer
                self._ser.reset_input_buffer()
                return
            % endif
            command_byte = self._ser.read(command_size)
            command_value = struct.unpack('<' + command_format, command_byte)
            command = COMMANDS(command_value[0])
            self._commands.get(command, self.command_error_cb)()
        # Yield thread
        time.sleep(0)

    # Callbacks
    # --------------------------------------------------
    # Callback called before initiating a write to master
    def pre_write_cb(self):
        pass

    # Callback called after finishing a write to master
    def post_write_cb(self):
        pass

    # Callback called before initiating a read from master
    def pre_read_cb(self):
        pass

    # Callback called after finishing a read from master
    def post_read_cb(self):
        pass

    # Callback called if a command received is not valid
    def command_error_cb(self):
        pass

    # Callback called when a read size fails
    def read_size_fail_cb(self):
        pass

    # Callback called when a CRC fails
    def read_crc_fail_cb(self):
        pass

    # Command callbacks
    # --------------------------------------------------
    % for command in commands:
    def ${command['name']}_cb(self\
% for output_arg in command['outputs']:
, ${output_arg['name']}\
% endfor
):
        """
        ${command['description']}
        % if len(command['outputs']) > 0:

        Arguments:
        % for output in command['outputs']:
        ${output['name']} (${output['type']}) -- ${output['description']}
        % endfor
        % endif
        % if len(command['inputs']) > 0:

        Returns:
        % for input in command['inputs']:
        ${input['name']} (${input['type']}) -- ${input['description']}
        % endfor
        % endif
        """
        pass

    % endfor

    # Internal functions
    # --------------------------------------------------
    def _write_packet(self, ack, data_format, *data):
        # Pre write callback
        self.pre_write_cb()
        # Full packet format string
        packet_format = ''.join(['<'\
% if connection['addressable']:
, address_format\
% endif
, ack_format, data_format\
% if connection['crc'] != 'none':
, crc_format\
% endif
])
        # Packet buffer
        packet_size = struct.calcsize(packet_format)
        packet_buffer = bytearray(packet_size)

        % if connection['addressable']:
        # Pack address
        struct.pack_into('<' + address_format, packet_buffer, 0, self.address)
        % endif
        # Pack ACK
        struct.pack_into('<' + ack_format, packet_buffer, 0\
% if connection['addressable']:
 + address_size\
% endif
, ack)
        # Pack data
        data = tuple(d.encode('ascii') if isinstance(d, str) else d for d in data)
        struct.pack_into('<' + data_format, packet_buffer, ack_size\
% if connection['addressable']:
 + address_size\
% endif
, *data)
        % if connection['crc'] != 'none':
        # Calculate CRC
        crc = crc_func(packet_buffer[0:(packet_size - crc_size)]) # CRC is always last bytes
        struct.pack_into('<' + crc_format, packet_buffer, (packet_size - crc_size), crc)
        % endif

        # Write buffer to serial
        self._ser.write(packet_buffer)
        # Post write callback
        self.post_write_cb()

    def _read_packet(self, command, data_format):
        # Pre read callback
        self.pre_read_cb()
        # Full packet format string
        packet_format = ''.join(['<'\
% if connection['addressable']:
, address_format\
% endif
, command_format, data_format\
% if connection['crc'] != 'none':
, crc_format\
% endif
])
        # Packet buffer
        packet_size = struct.calcsize(packet_format)
        packet_buffer = bytearray(packet_size)
        % if connection['addressable']:
        # Pack address into buffer to reconstruct full packet
        struct.pack_into('<' + address_format, packet_buffer, 0, self.address)
        % endif
        # Pack read command into buffer to reconstruct full packet
        struct.pack_into('<' + command_format, packet_buffer, 0\
% if connection['addressable']:
 + address_size\
% endif
, command.value)
        # Pack read data into buffer
        packet = self._ser.read(packet_size\
% if connection['addressable']:
 - address_size\
% endif
 - command_size)
        data_size = packet_size\
% if connection['addressable']:
 - address_size\
% endif
 - command_size\
% if connection['crc'] != 'none':
 - crc_size
% endif

        # Read failed either due to timeout or transmission error
        if len(packet) != packet_size\
% if connection['addressable']:
 - address_size\
% endif
 - command_size:
            print("Packet read size failed")
            self.read_size_fail_cb()
            return False, None

        # Copy packet into buffer
        packet_buffer[command_size\
% if connection['addressable']:
 + address_size\
% endif
:command_size + data_size\
% if connection['addressable']:
 + address_size\
% endif
] = packet
        % if connection['crc'] != 'none':
        # Unpack CRC and test
        sent_crc = struct.unpack_from('<' + crc_format, packet_buffer, (packet_size - crc_size))[0]
        calc_crc = crc_func(packet_buffer[0:(packet_size - crc_size)]) # CRC is always last bytes

        if sent_crc != calc_crc:
            print("Packet CRC failed!")
            self.read_crc_fail_cb()
            return False, None

        % endif
        # Unpack data
        data = struct.unpack_from('<' + data_format, packet_buffer, command_size\
% if connection['addressable']:
 + address_size\
% endif
)
        # Post read callback
        self.post_read_cb()
        return True, data

    % if heartbeat is not None:
    def _heartbeat_command(self):
        self._write_packet(True, '${type_map[heartbeat['size']]}', self._heartbeat_count)

    % endif
    def _hash_command(self):
        ret_read = self._read_packet(COMMANDS.${connection['hash_name']}, '')
        if ret_read[0]:
            self._write_packet(True, 'Q', 0x${connection['hash']})
        else:
            self._write_packet(False, '')
    % for command in commands:

    def _${command['name']}(self):
        ret_read = self._read_packet(COMMANDS.${command['NAME']}, '${''.join([type_map[i['type']] for i in command['inputs']])}')
        if ret_read[0]:
            % if len(command['inputs']) > 0:
            % if len(command['outputs']) > 0:
            ret_cb = \
            % else:
            \
            % endif
self.${command['name']}_cb(*ret_read[1])
            % else:
            % if len(command['outputs']) > 0:
            ret_cb = \
            % else:
            \
            % endif
self.${command['name']}_cb()
            % endif
            % if len(command['outputs']) > 0:
            self._write_packet(True, '${''.join([type_map[o['type']] for o in command['outputs']])}', ret_cb)
            % else:
            self._write_packet(True, '')
        else:
            self._write_packet(False, '')
        % endif
    % endfor
