<%
    import struct
    type_map = {
        'char': 'c',
        'int8': 'b',
        'uint8': 'B',
        'int16': 'h',
        'uint16':  'H',
        'int32': 'i',
        'uint32': 'I',
        'int64': 'q',
        'uint64': 'Q',
        'float': 'f',
        'string': 'p'
    }
    
    parity_map = {
        'none': 'serial.PARITY_NONE',
        'even': 'serial.PARITY_EVEN',
        'odd': 'serial.PARITY_ODD',
    }

    heartbeat_map = {
        'uint8': 8,
        'uint16': 16,
        'uint32': 32,
        'uint64': 64
    }
    crc_map = {
        'crc-8': 'crc-8',
        'crc-16': 'crc-16',
        'crc-32': 'crc-32',
        'crc-64': 'crc-64'
    }

    crc_size_map = {
        'crc-8': 'B',
        'crc-16': 'H',
        'crc-32': 'I',
        'crc-64': 'Q'
    }

    sof = '0x66'
    eof = '0x99'
    esc = '0xbd'
%>
'''
 WARNING: This file is autogenerated by SpaceCommander

 Any changes will be overwritten!
'''

import struct
import serial
import time
from enum import Enum
% if connection['crc'] != 'none':
import crcmod.predefined
crc_func = crcmod.predefined.mkCrcFun('${crc_map[connection['crc']]}')
crc_format = '${crc_size_map[connection['crc']]}'
crc_size = struct.calcsize(crc_format)
% endif
# Command format
command_format = 'B'
command_size = struct.calcsize(command_format)
# Ack format
ack_format = '?'
ack_size = struct.calcsize(ack_format)
% if connection['addressable']:
# Address format
address_format = 'B'
address_size = struct.calcsize(address_format)
% endif

class COMMANDS(Enum):
    % if heartbeat is not None:
    ${heartbeat['NAME']} = ${heartbeat['index']}
    % endif
    ${connection['hash_name']} = ${connection['hash_index']}
    % for command in commands:
    ${command['NAME']} = ${command['index']}
    % endfor


class SlaveBase:
    def __init__(self, port\
% if connection['addressable']:
, address\
% endif
):
        self._ser = serial.serial_for_url(port,
                                          baudrate=${connection['speed']},
                                          parity=${parity_map[connection['parity']]},
                                          % if 'timeout' in slave:
                                          timeout=(${slave['timeout']} / 1000),
                                          % endif
                                          do_not_open=True)
        % if connection['addressable']:
        self.address = address
        % endif
        self._commands = {
            % if heartbeat is not None:
            COMMANDS.${heartbeat['NAME']}: self._heartbeat_command,
            % endif
            COMMANDS.${connection['hash_name']}: self._hash_command,
            % for command in commands:
            COMMANDS.${command['NAME']}: self._${command['name']},
            % endfor
        }
        % if heartbeat is not None:
        self._heartbeat_count = 0
        self._heartbeat_max = 1 << ${heartbeat_map[heartbeat['size']]}
        % endif

    # User functions
    # --------------------------------------------------
    def begin(self):
        self._ser.open()

    def close(self):
        self._ser.close()

    def process_commands(self):
        if self._ser.in_waiting > 0:
            sof_byte = self._ser.read(1)
            if ord(sof_byte) == ${sof}:
                frame_buffer = self._ser.read_until(bytes([${eof}]))
                packet_buffer = self._unframe_packet(frame_buffer)
                if len(packet_buffer) < 1:
                    print("Improper packet")
                    self.read_bad_packet_cb()
                    return

                print("Read")
                print(frame_buffer.hex())
                print(packet_buffer.hex())

                % if connection['addressable']:
                address = struct.unpack_from('<' + address_format, packet_buffer, 0)[0]
                if address != self.address:
                    return
                % endif
                command_value = struct.unpack_from('<' + command_format, packet_buffer, 0\
% if connection['addressable']:
 + address_size\
% endif
)[0]
                command = COMMANDS(command_value)
                self._commands.get(command, self.command_error_cb)(packet_buffer)
        # Yield thread
        time.sleep(0)

    # Callbacks
    # --------------------------------------------------
    # Callback called before initiating a write to master
    def pre_write_cb(self):
        pass

    # Callback called after finishing a write to master
    def post_write_cb(self):
        pass

    # Callback called before initiating a read from master
    def pre_read_cb(self):
        pass

    # Callback called after finishing a read from master
    def post_read_cb(self):
        pass

    # Callback called if a command received is not valid
    def command_error_cb(self):
        pass

    # Callback called when a malformed packet is received
    def read_bad_packet_cb(self):
        pass
    
    # Callback called when a read size fails
    def read_size_fail_cb(self):
        pass

    # Callback called when a CRC fails
    def read_crc_fail_cb(self):
        pass

    # Command callbacks
    # --------------------------------------------------
    % for command in commands:
    def ${command['name']}_cb(self\
% for output_arg in command['outputs']:
, ${output_arg['name']}\
% endfor
):
        """
        ${command['description']}
        % if len(command['outputs']) > 0:

        Arguments:
        % for output in command['outputs']:
        ${output['name']} (${output['type']}) -- ${output['description']}
        % endfor
        % endif
        % if len(command['inputs']) > 0:

        Returns:
        % for input in command['inputs']:
        ${input['name']} (${input['type']}) -- ${input['description']}
        % endfor
        % endif
        """
        pass

    % endfor

    # Internal functions
    # --------------------------------------------------
    # Add start and end to frame and escape any framing bytes
    def _frame_packet(self, packet_buffer):
        frame = bytearray(0)
        frame.append(${sof})  # Start of frame
        for byte in packet_buffer:
            if byte == ${sof} or byte == ${eof} or byte == ${esc}:  # Escape any framing bytes
                new_byte = byte ^ ${esc}
                frame.append(${esc})
                frame.append(new_byte)
            else:
                frame.append(byte)  # Append normal bytes
        frame.append(${eof})  # End of frame
        return frame

    # Unescape framing bytes and remove end of frame (start of frame should already be removed from buffer)
    def _unframe_packet(self, frame_buffer):
        packet = bytearray(0)
        index = 0
        byte = frame_buffer[index]
        while byte != ${eof} and index < len(frame_buffer) - 1:
            if byte == ${esc}:  # Unescape any framing bytes
                index += 1
                byte = frame_buffer[index]
                new_byte = byte ^ ${esc}
                packet.append(new_byte)
            else:
                packet.append(byte)  # Append normal bytes
            index += 1
            byte = frame_buffer[index]

        if byte != ${eof}:  # Check for end of frame
            return bytearray(0)

        return packet

    def _write_packet(self, ack, data_format, *data):
        # Pre write callback
        self.pre_write_cb()
        # Full packet format string
        packet_format = ''.join(['<'\
% if connection['addressable']:
, address_format\
% endif
, ack_format, data_format\
% if connection['crc'] != 'none':
, crc_format\
% endif
])
        # Packet buffer
        packet_size = struct.calcsize(packet_format)
        packet_buffer = bytearray(packet_size)

        % if connection['addressable']:
        # Pack address
        struct.pack_into('<' + address_format, packet_buffer, 0, self.address)
        % endif
        # Pack ACK
        struct.pack_into('<' + ack_format, packet_buffer, 0\
% if connection['addressable']:
 + address_size\
% endif
, ack)
        # Pack data
        data = tuple(d.encode('ascii') if isinstance(d, str) else d for d in data)
        struct.pack_into('<' + data_format, packet_buffer, ack_size\
% if connection['addressable']:
 + address_size\
% endif
, *data)
        % if connection['crc'] != 'none':
        # Calculate CRC
        crc = crc_func(packet_buffer[0:(packet_size - crc_size)]) # CRC is always last bytes
        struct.pack_into('<' + crc_format, packet_buffer, (packet_size - crc_size), crc)
        % endif

        # Put packet into a frame
        frame_buffer = self._frame_packet(packet_buffer)
        print("Write")
        print(packet_buffer.hex())
        print(frame_buffer.hex())

        # Write buffer to serial
        self._ser.write(frame_buffer)
        # Post write callback
        self.post_write_cb()

    def _read_packet(self, packet_buffer, data_format):
        # Pre read callback
        self.pre_read_cb()
        # Full packet format string
        packet_format = ''.join(['<'\
% if connection['addressable']:
, address_format\
% endif
, command_format, data_format\
% if connection['crc'] != 'none':
, crc_format\
% endif
])
        # Packet size
        packet_size = struct.calcsize(packet_format)

        # Read failed either due to timeout or transmission error
        if len(packet_buffer) != packet_size:
            print("Packet read size failed")
            self.read_size_fail_cb()
            return False, None

        % if connection['crc'] != 'none':
        # Unpack CRC and test
        sent_crc = struct.unpack_from('<' + crc_format, packet_buffer, (packet_size - crc_size))[0]
        calc_crc = crc_func(packet_buffer[0:(packet_size - crc_size)]) # CRC is always last bytes

        if sent_crc != calc_crc:
            print("Packet CRC failed!")
            self.read_crc_fail_cb()
            return False, None

        % endif
        # Unpack data
        data = struct.unpack_from('<' + data_format, packet_buffer, command_size\
% if connection['addressable']:
 + address_size\
% endif
)
        # Post read callback
        self.post_read_cb()
        return True, data

    % if heartbeat is not None:
    # def _heartbeat_command(self):
    #     self._write_packet(True, '${type_map[heartbeat['size']]}', self._heartbeat_count)

    % endif
    def _hash_command(self, packet_buffer):
        ret_read = self._read_packet(packet_buffer, '')
        if ret_read[0]:
            self._write_packet(True, 'Q', 0x${connection['hash']})
        else:
            self._write_packet(False, '')
    % for command in commands:

    def _${command['name']}(self, packet_buffer):
        ret_read = self._read_packet(packet_buffer, '${''.join([type_map[i['type']] for i in command['inputs']])}')
        if ret_read[0]:
            % if len(command['inputs']) > 0:
            % if len(command['outputs']) > 0:
            ret_cb = \
            % else:
            \
            % endif
self.${command['name']}_cb(*ret_read[1])
            % else:
            % if len(command['outputs']) > 0:
            ret_cb = \
            % else:
            \
            % endif
self.${command['name']}_cb()
            % endif
            % if len(command['outputs']) > 0:
            self._write_packet(True, '${''.join([type_map[o['type']] for o in command['outputs']])}', ret_cb)
            % else:
            self._write_packet(True, '')
        else:
            self._write_packet(False, '')
        % endif
    % endfor
