/*
 * WARNING: This file is autogenerated by SpaceCommander
 *
 * Any changes will be overwritten!
 */
<%
type_map = { 'char': 'char',
             'int8': 'char',
             'uint8': 'unsigned char',
             'int16': 'int',
             'uint16': 'unsigned int',
             'int32': 'long',
             'uint32': 'unsigned long',
        'float': 'float' }
%>
#ifndef SPACECOMMANDS_HOST_HPP
#define SPACECOMMANDS_HOST_HPP

#include <Arduino.h>

namespace spcmds {

template <typename T>
class Device {
    T* m_serial;
public:
    Device() {}
    Device(T& serial);

    ////////////////////////
    // GENERATED COMMANDS //
    ////////////////////////

    /**
      * Check hash
      */
    bool check_hash();

    % for cmd_idx, command in enumerate(commands_config):
    /**
      * ${command['description']}
      % if len(command['inputs']) > 0:
      *
      * Inputs:
      % endif
      % for input_arg in command['inputs']:
      * @param in_${input_arg['name']} ${input_arg['description']}
      % endfor
      % if len(command['outputs']) > 0:
      *
      * Outputs:
      % endif
      % for output_arg in command['outputs']:
      * @param out_${output_arg['name']} ${output_arg['description']}
      % endfor
      */
    void ${command['name']}(
       % for input_idx, input_arg in enumerate(command['inputs']):
      ${type_map[input_arg['type']]} in_${input_arg['name']}\
       % if input_idx < len(command['inputs']) - 1 or len(command['outputs']) > 0:
,\
       % endif

       % endfor
       % for output_idx, output_arg in enumerate(command['outputs']):
      ${type_map[output_arg['type']]}& out_${output_arg['name']}\
       % if output_idx < len(command['outputs']) - 1:
,\
       % endif

       % endfor
    );
    
    % endfor
    ////////////////////////////////////////////
    // Implement these methods in source file //
    ////////////////////////////////////////////
    void version_error(char* hash_buff, int len);
};

//////////////
// INTERNAL //
//////////////

enum host_commands {
    SENDHASH_HOST,
    % for command in commands_config:
    SPCMDS_HOST_${command['name'].upper()},
    % endfor
};

template <typename T>
Device<T>::Device(T& serial)
    : m_serial(&serial) {
    m_serial->begin(${connection_config['baudrate']});
    m_serial->setTimeout(${int(host_config['timeout'] * 1000)});

    while (!check_hash())
      delay(100);
}

template <typename T>
bool Device<T>::check_hash() {
    m_serial->write((byte)SENDHASH_HOST);
    m_serial->flush();
    while (!m_serial->available());
    char hash_buff[${len(hashval)}];
    m_serial->readBytes(hash_buff, ${len(hashval)});
    if (memcmp(hash_buff, "${hashval}", ${len(hashval)}) != 0) {
        version_error(hash_buff, ${len(hashval)});
        return false;
    }
    return true;
}

% for cmd_idx, command in enumerate(commands_config):
template <typename T>
void Device<T>::${command['name']}(
  % for input_idx, input_arg in enumerate(command['inputs']):
  ${type_map[input_arg['type']]} in_${input_arg['name']}\
  % if input_idx < len(command['inputs']) - 1 or len(command['outputs']) > 0:
,\
  % endif

  % endfor
  % for output_idx, output_arg in enumerate(command['outputs']):
  ${type_map[output_arg['type']]}& out_${output_arg['name']}\
  % if output_idx < len(command['outputs']) - 1:
,\
  % endif

  % endfor
) {
    m_serial->write((byte)SPCMDS_HOST_${command['name'].upper()});
    m_serial->flush();
    % for input_idx, input_arg in enumerate(command['inputs']):
    m_serial->write((char*) &in_${input_arg['name']}, sizeof(in_${input_arg['name']}));
    % endfor
    m_serial->flush();
    while (!m_serial->available());
    % for output_idx, output_arg in enumerate(command['outputs']):
    m_serial->readBytes((char*) &out_${output_arg['name']}, sizeof(out_${output_arg['name']}));
    % endfor
    % if len(command['outputs']) == 0:
    char command_end;
    m_serial->readBytes(&command_end, sizeof(command_end));
    % endif
}

% endfor
} // namespace spcmds

#endif // SPACECOMMANDS_HOST_HPP
