<%
    type_map = {
        'char': 'char',
        'int8': 'int8_t',
        'uint8': 'uint8_t',
        'int16': 'int16_t',
        'uint16':  'uint16_t',
        'int32': 'int32_t',
        'uint32': 'uint32_t',
        'int64': 'int64_t',
        'uint64': 'uint64_t',
        'float': 'float',
        'string': 'char*'
    }
    
    parity_map = {
        'none': '',
        'even': '',
        'odd': '',
    }

    size_map = {
        'char': 1,
        'int8': 1,
        'uint8': 1,
        'int16': 2,
        'uint16':  2,
        'int32': 4,
        'uint32': 4,
        'int64': 8,
        'uint64': 8,
        'float': 4,
        'string': 4
    }

    heartbeat_map = {
        'uint8': 1,
        'uint16': 2,
        'uint32': 3,
        'uint64': 4
    }

    crc_map = {
        'crc-8': 'crc-8',
        'crc-16': 'crc-16',
        'crc-32': 'crc-32',
        'crc-64': 'crc-64'
    }

    crc_type_map = {
        'crc-8': 'uint8_t',
        'crc-16': 'uint16_t',
        'crc-32': 'uint32_t',
        'crc-64': 'uint64_t'
    }

    crc_size_map = {
        'crc-8': 1,
        'crc-16': 2,
        'crc-32': 4,
        'crc-64': 8
    }

    if connection['crc'] != 'none':
        import io
        import crcmod
        crc_func = crcmod.predefined.PredefinedCrc(crc_map[connection['crc']])
        crc_file = io.StringIO('')
        crc_func.generateCode('crc_func', crc_file)
        crc_file.seek(0)
        crc_str = crc_file.read()
        types = list(type_map.keys())
        types.sort(key=len, reverse=True)
        for key in types:
            crc_str = crc_str.replace(key.upper(), type_map[key])
        crc_str = crc_str.replace(' int ', ' int16_t ')

    sof = '0x66'
    eof = '0x99'
    esc = '0xBD'
%>
/*
 * WARNING: This file is autogenerated by SpaceCommander
 *
 * Any changes will be overwritten!
 */
#ifndef SPACECOMMANDS_MASTER_HPP
#define SPACECOMMANDS_MASTER_HPP

#include <Arduino.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

namespace spcmd_master {

template<typename T> constexpr
T const c_max(T const a) {
  return a;
}

template<typename T> constexpr
T const c_max(T const a, T const b) {
  return a > b ? a : b;
}

template<typename T, typename... Args> constexpr
T const c_max(T const a, T const b, Args... args) {
  return a > b ? c_max(a, args...) : c_max(b, args...);
}

static const uint64_t master_hash = 0x${connection['hash']}ULL;
using command_type = uint8_t;
using ack_type = uint8_t;

% if connection['crc'] != 'none':
${crc_str}
% endif

// Command Data Structs
% for command in commands:
struct ${command['name']}_in {
  % for arg in command['inputs']:
  ${type_map[arg['type']]} ${arg['name']};
  % endfor
} __attribute__((packed));
struct ${command['name']}_out {
  % for arg in command['outputs']:
  ${type_map[arg['type']]} ${arg['name']};
  % endfor
  bool read_success;
} __attribute__((packed));
  
% endfor

struct hash_in {
} __attribute__((packed));
struct hash_out {
  uint64_t hash;
  bool read_success;
} __attribute__((packed));

static const size_t max_data_size = c_max(
                                          % for command in commands:
                                          sizeof(${command['name']}_in), sizeof(${command['name']}_out),
                                          % endfor
                                          sizeof(hash_in), sizeof(hash_out)
                                          );

// Callbacks
// --------------------------------------------------
void pre_write_cb();
void post_write_cb();
void pre_read_cb();
void post_read_cb();
void read_no_response_cb();
% if connection['addressable']:
void read_address_mismatch_cb();
% endif
void read_size_fail_cb();
void read_crc_fail_cb();
void read_nack_cb();

// Commands

enum COMMANDS : command_type {
    % if heartbeat is not None:
    ${heartbeat['NAME']} = ${heartbeat['index']},
    % endif
    ${connection['hash_name']} = ${connection['hash_index']},
    % for command in commands:
    ${command['NAME']} = ${command['index']},
    % endfor
};

template <typename T>
class Master {
public:

  Master() {}
  Master(T& serial);
  
  // User functions
  // --------------------------------------------------
  void begin();
  void close();
  bool update();
  bool test_hash(\
% if connection['addressable']:
const uint8_t address\
% endif
);

  % for command in commands:
  ${command['name']}_out ${command['name']}(\
% if connection['addressable']:
const uint8_t address\
%endif
% for idx, arg in enumerate(command['inputs']):
, const ${type_map[arg['type']]} ${arg['name']}\
% endfor
);
  % endfor

protected:
  struct write_buffer_t{
    % if connection['addressable']:
    uint8_t address;
    % endif
    COMMANDS command;
    uint8_t data[max_data_size];
    % if connection['crc'] != 'none':
    ${crc_type_map[connection['crc']]} crc;
    % endif
  } __attribute__((packed));
  struct read_buffer_t {
    % if connection['addressable']:
    uint8_t address;
    % endif
    ack_type ack;
    uint8_t data[max_data_size];
    % if connection['crc'] != 'none':
    ${crc_type_map[connection['crc']]} crc;
    % endif
  } __attribute__((packed));
  struct frame_buffer_t {
    uint8_t data[c_max(sizeof(write_buffer_t), sizeof(read_buffer_t)) * 2 + 2];
  } __attribute__((packed));

  // Internal functions
  // --------------------------------------------------
  size_t frame_packet(const size_t len);
  void unframe_packet(const size_t len);
  void write_packet(\
% if connection['addressable']:
const uint8_t address, \
% endif
const COMMANDS command, const size_t len);
  bool read_packet(\
% if connection['addressable']:
const uint8_t address, \
% endif
const size_t len);
  hash_out hash_command(\
% if connection['addressable']:
const uint8_t address\
% endif
);

private:
  T* m_serial;
  write_buffer_t m_write_buffer;
  read_buffer_t m_read_buffer;
  frame_buffer_t m_frame_buffer;
};

// Internal functions
// --------------------------------------------------
// Copies data from m_write_buffer into m_frame_buffer, framing it appropriately
// len should be the size of everything but CRC
template <typename T>
size_t Master<T>::frame_packet(const size_t len) {
  m_frame_buffer.data[0] = ${sof};
  size_t index = 1;
  for (size_t i = 0; i < len; ++i, ++index) {
    uint8_t byte = reinterpret_cast<const uint8_t*>(&m_write_buffer)[i];
    if (byte == ${sof} || byte == ${eof} || byte == ${esc}) {
      m_frame_buffer.data[index] = ${esc};
      index++;
      m_frame_buffer.data[index] = byte ^ ${esc};
    }
    else {
      m_frame_buffer.data[index] = byte;
    }
  }
  % if connection['crc'] != 'none':
  // CRC
  for (size_t i = 0; i < sizeof(m_write_buffer.crc); ++i, ++index) {
    uint8_t byte = reinterpret_cast<const uint8_t*>(&m_write_buffer.crc)[i];
    if (byte == ${sof} || byte == ${eof} || byte == ${esc}) {
      m_frame_buffer.data[index] = ${esc};
      index++;
      m_frame_buffer.data[index] = byte ^ ${esc};
    }
    else {
      m_frame_buffer.data[index] = byte;
    }
  }
  % endif
  m_frame_buffer.data[index] = ${eof};
  index++;
  return index;
}

// Unframes data from the m_frame_buffer into m_read_buffer
template <typename T>
void Master<T>::unframe_packet(const size_t len) {
  size_t frame_index = 0;
  uint8_t byte = m_frame_buffer.data[frame_index];
  uint8_t* read_buffer = reinterpret_cast<uint8_t*>(&m_read_buffer);
  while (frame_index < len) {
    if (byte == ${esc}) {
      frame_index++;
      byte = m_frame_buffer.data[frame_index];
      uint8_t new_byte = byte ^ ${esc};
      *read_buffer++ = new_byte;
    }
    else {
      *read_buffer++ = byte;
    }
    frame_index++;
    byte = m_frame_buffer.data[frame_index];
  }

  % if connection['crc'] != 'none':
  // Check the size, and move the last bytes of data into the CRC region if necessary
  // Go backwards to avoid overwriting if it overlaps CRC region
  uint8_t* crc_buffer = reinterpret_cast<uint8_t*>(&m_read_buffer.crc) + sizeof(m_read_buffer.crc) - 1;
  read_buffer--;
  if ((read_buffer - reinterpret_cast<uint8_t*>(&m_read_buffer)) < sizeof(m_read_buffer) - 1) {
    for (size_t i = 0; i < sizeof(m_read_buffer.crc); ++i) {
      *crc_buffer-- = *read_buffer--;
    }
  }
  % endif
}

template <typename T>
void Master<T>::write_packet(\
% if connection['addressable']:
const uint8_t address, \
% endif
const COMMANDS command, const size_t len) {
  // Pre write callback
  pre_write_cb();

  % if connection['addressable']:
  // Put address into buffer
  m_write_buffer.address = address;
  % endif
  // Put command into buffer
  m_write_buffer.command = command;
  % if connection['crc'] != 'none':
  // Calculate CRC
  m_write_buffer.crc = crc_func(reinterpret_cast<uint8_t*>(&m_write_buffer),\
% if connection['addressable']:
 sizeof(uint8_t) +\
% endif
 sizeof(command) + len, 0);
  % endif
  // Put data into frame
  size_t frame_size = frame_packet(\
% if connection['addressable']:
sizeof(uint8_t) + \
% endif
sizeof(command) + len);
  // Write frame to serial
  m_serial->write(reinterpret_cast<const uint8_t*>(&m_frame_buffer.data), frame_size);
  m_serial->flush();
  // Post write callback
  post_write_cb();
}

template <typename T>
bool Master<T>::read_packet(\
% if connection['addressable']:
const uint8_t address, \
% endif
const size_t len) {
  // Pre read callback
  pre_read_cb();

  long start = micros();
  long current = micros();
  while (current - start < ${master['timeout']} * 1000) {
    // Discard any bytes received before a SOF byte
    uint8_t sof_byte;
    m_serial->readBytes(&sof_byte, sizeof(sof_byte));
    if (sof_byte == ${sof}) {
      size_t frame_size = m_serial->readBytesUntil(${eof}, m_frame_buffer.data, sizeof(m_frame_buffer.data));
      unframe_packet(frame_size);
      % if connection['addressable']:
      if (m_read_buffer.address != address) {
        read_address_mismatch_cb();
        return false;
      }
      % endif
      if (!m_read_buffer.ack) {
        read_nack_cb();
        return false;
      }
      % if connection['crc'] != 'none':
      // Test CRC
      ${crc_type_map[connection['crc']]} calc_crc = crc_func(reinterpret_cast<uint8_t*>(&m_read_buffer), \
% if connection['addressable']:
 sizeof(uint8_t) +\
% endif
 sizeof(m_read_buffer.ack) + len, 0);
      if (m_read_buffer.crc != calc_crc) {
        read_crc_fail_cb();
        return false;
      }
      % endif
      return true;
    }
    current = micros();
  }
  read_no_response_cb();
  return false;
}

template <typename T>
hash_out Master<T>::hash_command(\
% if connection['addressable']:
const uint8_t address\
% endif
) {
  write_packet(\
% if connection['addressable']:
address, \
% endif
${connection['hash_name']}, 0);
  hash_out output_buffer;
  bool read_success = read_packet(\
% if connection['addressable']:
address, \
% endif
sizeof(output_buffer) - sizeof(output_buffer.read_success));
  if (read_success) {
    output_buffer = *(reinterpret_cast<hash_out*>(&(m_read_buffer.data)));
  }
  output_buffer.read_success = read_success;
  return output_buffer;
}

// User functions
// --------------------------------------------------
template <typename T>
Master<T>::Master(T& serial)
  : m_serial(&serial) {
  % if 'timeout' in master:
  m_serial->setTimeout(${master['timeout']});
  % endif
}

template <typename T>
void Master<T>::begin() {
  m_serial->begin(${connection['speed']});
}
  
template <typename T>
void Master<T>::close() {
  m_serial->end();
}

template <typename T>
bool Master<T>::test_hash(\
% if connection['addressable']:
const uint8_t address\
% endif
) {
  hash_out response = hash_command(\
% if connection['addressable']:
address\
% endif
);
  return response.read_success && (response.hash == master_hash);
}
  
% for command in commands:
template <typename T>
${command['name']}_out Master<T>::${command['name']}(\
% if connection['addressable']:
const uint8_t address\
%endif
% for idx, arg in enumerate(command['inputs']):
, const ${type_map[arg['type']]} ${arg['name']}\
% endfor
) {
  % if len(command['inputs']) == 0:
  write_packet(\
% if connection['addressable']:
address, \
% endif
${command['NAME']}, 0);
  % else:
  ${command['name']}_in* input_buffer = reinterpret_cast<${command['name']}_in*>(&(m_write_buffer.data));
  % for arg in command['inputs']:
  input_buffer->${arg['name']} = ${arg['name']};
  % endfor
  write_packet(\
% if connection['addressable']:
address, \
% endif
${command['NAME']}, sizeof(${command['name']}_in));
  % endif
  ${command['name']}_out output_buffer;
  % if len(command['outputs']) == 0:
  bool read_success = read_packet(\
% if connection['addressable']:
address, \
% endif
0);
  % else:
  bool read_success = read_packet(\
% if connection['addressable']:
address, \
% endif
sizeof(output_buffer) - sizeof(output_buffer.read_success));
  % endif
  if (read_success) {
    output_buffer = *(reinterpret_cast<${command['name']}_out*>(&(m_read_buffer.data)));
  }
  output_buffer.read_success = read_success;
  return output_buffer;
}

% endfor

} // namespace spcmds

#endif // SPACECOMMANDS_HOST_HPP
