/*
 * WARNING: This file is autogenerated by SpaceCommander
 *
 * Any changes will be overwritten!
 */
<%
    type_map = {
        'char': 'char',
        'int8': 'int8_t',
        'uint8': 'uint8_t',
        'int16': 'int16_t',
        'uint16':  'uint16_t',
        'int32': 'int32_t',
        'uint32': 'uint32_t',
        'int64': 'int64_t',
        'uint64': 'uint64_t',
        'float': 'float',
        'string': 'char*'
    }
    
    parity_map = {
        'none': '',
        'even': '',
        'odd': '',
    }

    size_map = {
        'char': 1,
        'int8': 1,
        'uint8': 1,
        'int16': 2,
        'uint16':  2,
        'int32': 4,
        'uint32': 4,
        'int64': 8,
        'uint64': 8,
        'float': 4,
        'string': 4
    }

    heartbeat_map = {
        'uint8': 1,
        'uint16': 2,
        'uint32': 3,
        'uint64': 4
    }

    crc_map = {
        'crc-8': 'crc-8',
        'crc-16': 'crc-16',
        'crc-32': 'crc-32',
        'crc-64': 'crc-64'
    }

    crc_type_map = {
        'crc-8': 'uint8_t',
        'crc-16': 'uint16_t',
        'crc-32': 'uint32_t',
        'crc-64': 'uint64_t'
    }

    crc_size_map = {
        'crc-8': 1,
        'crc-16': 2,
        'crc-32': 4,
        'crc-64': 8
    }

    if connection['crc'] != 'none':
        import io
        import crcmod
        crc_func = crcmod.predefined.PredefinedCrc(crc_map[connection['crc']])
        crc_file = io.StringIO('')
        crc_func.generateCode('crc_func', crc_file)
        crc_file.seek(0)
        crc_str = crc_file.read()
        types = list(type_map.keys())
        types.sort(key=len, reverse=True)
        for key in types:
            crc_str = crc_str.replace(key.upper(), type_map[key])
        crc_str = crc_str.replace(' int ', ' int16_t ')
%>
#ifndef SPACECOMMANDS_SLAVE_HPP
#define SPACECOMMANDS_SLAVE_HPP

#include <Arduino.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

namespace spcmd_slave {

template<typename T> constexpr
T const c_max(T const a) {
  return a;
}

template<typename T> constexpr
T const c_max(T const a, T const b) {
  return a > b ? a : b;
}

template<typename T, typename... Args> constexpr
T const c_max(T const a, T const b, Args... args) {
  return a > b ? c_max(a, args...) : c_max(b, args...);
}

static const uint64_t slave_hash = 0x${connection['hash']}ULL;
using command_type = uint8_t;
using ack_type = uint8_t;

% if connection['crc'] != 'none':
${crc_str}
% endif

// Command Data Structs
% for command in commands:
struct ${command['name']}_in {
  % for arg in command['inputs']:
  ${type_map[arg['type']]} ${arg['name']};
% endfor
} __attribute__((packed));
struct ${command['name']}_out {
  % for arg in command['outputs']:
  ${type_map[arg['type']]} ${arg['name']};
  % endfor
} __attribute__((packed));
  
% endfor

struct hash_in {
};
struct hash_out {
  uint64_t hash;
};

static const size_t max_data_size = c_max(
                                          % for command in commands:
                                          sizeof(${command['name']}_in), sizeof(${command['name']}_out),
                                          % endfor
                                          sizeof(hash_in), sizeof(hash_out)
                                          );

// --------------------------------------------------
% for command in commands:
/**************************************************
 * ${command['description']}
 % if len(command['inputs']) > 0:
 *
 * Inputs:
 % for arg in command['inputs']:
 * @param ${arg['name']} ${arg['description']}
 % endfor
 % endif
 % if len(command['outputs']) > 0:
 *
 * Outputs:
 * Struct of type ${command['name']}_out, which has the following
 * data members:
 % for arg in command['outputs']:
 * @param ${arg['name']} ${arg['description']}
 % endfor
 % endif
 **************************************************/
${command['name']}_out ${command['name']}_cb(\
% for idx, arg in enumerate(command['inputs']):
${type_map[arg['type']]} ${arg['name']}\
% if idx < len(command['inputs']) - 1:
, \
% endif
% endfor
);

% endfor
  
// Callbacks
// --------------------------------------------------
void pre_write_cb();
void post_write_cb();
void pre_read_cb();
void post_read_cb();
void command_error_cb();
void read_size_fail_cb();
void read_crc_fail_cb();

// Commands

enum COMMANDS : command_type {
    % if heartbeat is not None:
    ${heartbeat['NAME']} = ${heartbeat['index']},
    % endif
    ${connection['hash_name']} = ${connection['hash_index']},
    % for command in commands:
    ${command['NAME']} = ${command['index']},
    % endfor
};

template <typename T>
class Slave {
public:

  Slave() {}
  Slave(T& serial\
% if connection['addressable']:
, uint8_t address\
% endif
);

  // User functions
  // --------------------------------------------------
  void begin();
  void close();
  bool update();

protected:
  struct write_buffer_t{
    % if connection['addressable']:
    uint8_t address;
    % endif
    ack_type ack;
    uint8_t data[max_data_size];
    % if connection['crc'] != 'none':
    ${crc_type_map[connection['crc']]} crc;
    % endif
  } __attribute__((packed));
  struct read_buffer_t {
    % if connection['addressable']:
    uint8_t address;
    % endif
    COMMANDS command;
    uint8_t data[max_data_size];
    % if connection['crc'] != 'none':
    ${crc_type_map[connection['crc']]} crc;
    % endif
  } __attribute__((packed));
  // Internal functions
  // --------------------------------------------------
  void write_packet(const bool ack, const size_t len);
  bool read_packet(const size_t len);
  void hash_command();

  % for command in commands:
  void ${command['name']}();
  % endfor
  
private:
  T* m_serial;
  write_buffer_t m_write_buffer;
  read_buffer_t m_read_buffer;
  % if connection['addressable']:
  uint8_t m_address;
  % endif
};

// User functions
// --------------------------------------------------
template <typename T>
Slave<T>::Slave(T& serial\
% if connection['addressable']:
, uint8_t address\
% endif
)
  : m_serial(&serial)\
% if connection['addressable']:
, m_address(address)\
% endif
 {
  % if 'timeout' in slave:
  m_serial->setTimeout(${slave['timeout']});
  % endif
  m_write_buffer.address = m_address;
  m_read_buffer.address = m_address;
}

template <typename T>
void Slave<T>::begin(){
  m_serial->begin(${connection['speed']});
}
  
template <typename T>
void Slave<T>::close(){
  m_serial->end();
} 
  
template <typename T>
bool Slave<T>::update() {
  if (m_serial->available() > 0) {
    % if connection['addressable']:
    uint8_t address;
    m_serial->readBytes(&address, sizeof(address));
    if (address != m_address) {
      // Wait until we stop receiving bytes to start reading again
      delay(2 * 8 * 1000 / ${connection['speed']});
      while (m_serial->available() > 0) {
        // Dump input buffer
        while (m_serial->available() > 0) {
          m_serial->read();
        }
        delay(2 * 8 * 1000 / ${connection['speed']});
      }
      return true;
    }
    % endif
    COMMANDS command;
    m_serial->readBytes(reinterpret_cast<uint8_t*>(&command), sizeof(command));
    // Place command into buffer
    m_read_buffer.command = command;
    // Switch to function table lookup
    switch(command) {
    % if heartbeat is not None:
    case COMMANDS::${heartbeat['NAME']}:
      //heartbeat();
      break;
    % endif
    case COMMANDS::${connection['hash_name']}:
      hash_command();
      break;
    % for command in commands:
    case COMMANDS::${command['NAME']}:
      ${command['name']}();
      break;
    % endfor
    default:
      return false;
    }
  }
  return true;
}

// Internal functions
// --------------------------------------------------
template <typename T>
void Slave<T>::write_packet(const bool ack, const size_t len) {
  // Pre write callback
  pre_write_cb();

  // Write ack into buffer
  m_write_buffer.ack = static_cast<ack_type>(ack);
  % if connection['crc'] != 'none':
  // Calculate CRC
  m_write_buffer.crc = crc_func(reinterpret_cast<uint8_t*>(&m_write_buffer),\
% if connection['addressable']:
 sizeof(uint8_t) +\
% endif
 sizeof(ack) + len, 0);
  % endif
  // Write data
  m_serial->write(reinterpret_cast<const uint8_t*>(&m_write_buffer),\
% if connection['addressable']:
 sizeof(uint8_t) +\
% endif
 sizeof(ack) + len);
  % if connection['crc'] != 'none':
  // Write crc
  m_serial->write(reinterpret_cast<const uint8_t*>(&(m_write_buffer.crc)), sizeof(m_write_buffer.crc));
  % endif
  m_serial->flush();
  // Post write callback
  post_write_cb();
}

template <typename T>
bool Slave<T>::read_packet(const size_t len) {
  // Pre read callback
  pre_read_cb();
  // Read from serial
  size_t read_bytes = m_serial->readBytes(reinterpret_cast<uint8_t*>(&(m_read_buffer.data)), len);
  // Read failed either due to timeout or transmission error
  if (read_bytes != len) {
    read_size_fail_cb();
    return false;
  }
  % if connection['crc'] != 'none':
  // Read CRC
  read_bytes = m_serial->readBytes(reinterpret_cast<uint8_t*>(&(m_read_buffer.crc)), sizeof(m_read_buffer.crc));
  if (read_bytes != sizeof(m_read_buffer.crc)) {
    read_size_fail_cb();
    return false;
  }
  % endif
  % if connection['crc'] != 'none':
  // Test CRC
  ${crc_type_map[connection['crc']]} calc_crc = crc_func(reinterpret_cast<uint8_t*>(&m_read_buffer),\
% if connection['addressable']:
 sizeof(uint8_t) +\
% endif
 sizeof(m_read_buffer.command) + len, 0);
  if (m_read_buffer.crc != calc_crc) {
    read_crc_fail_cb();
    return false;
  }
  % endif
  // Post read callback
  post_read_cb();
  return true;
}

template <typename T>
void Slave<T>::hash_command() {
  bool read_success = read_packet(0);
  if (read_success) {
    memcpy(m_write_buffer.data, &slave_hash, sizeof(slave_hash));
    write_packet(true, sizeof(slave_hash));
  }
  else {
    write_packet(false, 0);
  }
}

% for command in commands:
template <typename T>
void Slave<T>::${command['name']}() {
  % if len(command['inputs']) == 0:
  bool read_success = read_packet(0);
  % else:
  bool read_success = read_packet(sizeof(${command['name']}_in));
  % endif
  if (read_success) {
    ${command['name']}_in* input_buffer = reinterpret_cast<${command['name']}_in*>(&(m_read_buffer.data));
    ${command['name']}_out output_buffer = ${command['name']}_cb(\
% for idx, arg in enumerate(command['inputs']):
input_buffer->${arg['name']}\
% if idx < len(command['inputs']) - 1:
, \
% endif
% endfor
);

    % if len(command['outputs']) == 0:
    write_packet(true, 0);
    % else:
    memcpy(m_write_buffer.data, &output_buffer, sizeof(output_buffer));
    write_packet(true, sizeof(output_buffer));
    % endif
  }
  else {
    write_packet(false, 0);
  }
}

% endfor

} // namespace spcmds

#endif // SPACECOMMANDS_HPP
