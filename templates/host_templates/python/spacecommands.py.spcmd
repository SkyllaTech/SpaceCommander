'''
 WARNING: This file is autogenerated by SpaceCommander

 Any changes will be overwritten!
'''

import struct
import serial
import time
<%
    import struct
    type_map = { 'char': 'c', 'int8': 'b', 'uint8': 'B', 'int16': 'h', 'uint16':  'H', 'int32': 'i', 'uint32': 'I', 'float': 'f' }
%>

class Device:
    def __init__(self, port):
        self.ser = serial.serial_for_url(port, baudrate=${device_config['baudrate']}, timeout=${host_config['timeout']})
        while self.ser.in_waiting == 0:
            time.sleep(0.001)
        hashval = self.ser.read(${len(hashval)})
        if hashval != b'${hashval}':
            print('received hash {} but expected {}'.format(hashval, b'${hashval}'))

    def close(self):
        self.ser.close()

    % for cmd_idx, command in enumerate(commands):
    % if command['host'] == 'device':
    def ${command['name']}(self\
% for input_arg in command['inputs']:
, in_${input_arg['name']}\
% endfor
):
        packed_struct = struct.pack('<b${''.join([type_map[i['type']] for i in command['inputs']])}', ${cmd_idx}\
% for idx, input_arg in enumerate(command['inputs']):
, in_${input_arg['name']}\
% endfor
)
        self.ser.write(packed_struct)
        ##self.ser.write(struct.pack('b${''.join([type_map[i['type']] for i in command['inputs']])}', ${cmd_idx}\
##% for idx, input_arg in enumerate(command['inputs']):
##, in_${input_arg['name']}\
##% endfor
##))
        <%
        read_str_format = '<{}'.format(''.join([type_map[o['type']] for o in command['outputs']]))
        struct_num_bytes = struct.Struct(read_str_format).size
        %>
        ret_val = self.ser.read(${struct_num_bytes})
        % if len(command['outputs']) > 1:
        return struct.unpack('${read_str_format}', ret_val)

        % elif len(command['outputs']) > 0:
        return struct.unpack('${read_str_format}', ret_val)[0]

        % endif
    % endif
    % endfor
