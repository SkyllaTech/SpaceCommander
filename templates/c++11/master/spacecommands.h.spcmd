'''
 WARNING: This file is autogenerated by SpaceCommander

 Any changes will be overwritten!
'''

import struct
import serial
import time
from enum import Enum
<%
    import struct
    type_map = {
        'char': 'c',
        'int8': 'b',
        'uint8': 'B',
        'int16': 'h',
        'uint16':  'H',
        'int32': 'i',
        'uint32': 'I',
        'int64': 'q',
        'uint64': 'Q',
        'float': 'f',
        'string': 'p'
    }
    
    parity_map = {
        'none': 'serial.PARITY_NONE',
        'even': 'serial.PARITY_EVEN',
        'odd': 'serial.PARITY_ODD',
    }

    heartbeat_map = {
        'uint8': 8,
        'uint16': 16,
        'uint32': 32,
        'uint64': 64
    }
%>

class COMMANDS(Enum):
    % if heartbeat is not None:
    ${heartbeat['NAME']} = ${heartbeat['index']}
    % endif
    ${connection['hash_name']} = ${connection['hash_index']}
    % for command in commands:
    ${command['NAME']} = ${command['index']}
    % endfor

    
class MasterBase:
    def __init__(self, port):
        self._ser = serial.serial_for_url(port,
                                          baudrate=${connection['speed']},
                                          parity=${parity_map[connection['parity']]},
                                          % if 'timeout' in master:
                                          timeout=${master['timeout']},
                                          % endif
                                          do_not_open=True)

    
    # User functions
    # --------------------------------------------------
    def begin(self):
        self._ser.open()
        if not self.test_hash():
            self._ser.close()
            
    def close(self):
        self._ser.close()

    def test_hash(self):
        hash_val = self._hash_command()
        if hash_val != 0x${connection['hash']}:
            print('Hash Mismatch! Received hash {} but expected {}. Ensure both host and device are the same version.'.format(hex(hash_val), b'${connection['hash']}'.upper()))
            return False
        return True

    # Callbacks
    # --------------------------------------------------
    # Callback called before initiating a write to a slave
    def pre_write_cb(self, command, *data):
        pass

    # Callback called after finishing a write to a slave
    def post_write_cb(self, command, *data):
        pass

    # Callback called before initiating a read from a slave
    def pre_read_cb(self):
        pass

    # Callback called after finishing a read from a slave
    def post_read_cb(self, *data):
        pass
        
    # Commands
    # --------------------------------------------------
    % for command in commands:
    def ${command['name']}(self\
% for input_arg in command['inputs']:
, ${input_arg['name']}\
% endfor                          
):
        """
        ${command['description']}
        % if len(command['inputs']) > 0:

        Arguments:
        % for input in command['inputs']:
        ${input['name']} (${input['type']}) -- ${input['description']}
        % endfor
        % endif
        % if len(command['outputs']) > 0:
        
        Returns:
        % for output in command['outputs']:
        ${output['name']} (${output['type']}) -- ${output['description']}
        % endfor
        % endif
        """
        self._write_packet(COMMANDS.${command['NAME']}, '${''.join([type_map[i['type']] for i in command['inputs']])}'\
% for input_arg in command['inputs']:
% if input_arg['type'] == 'char':
, ${input_arg['name']}.encode('utf-8')\
% else:
, ${input_arg['name']}\
% endif
% endfor
)
        ret_val = self._read_packet('${''.join([type_map[o['type']] for o in command['outputs']])}')
        % if len(command['outputs']) > 0:
        return ret_val\
% if len(command['outputs']) == 1:
[0]
% endif
% endif

    % endfor
    
    # Internal functions
    # --------------------------------------------------
    def _write_packet(self, command_name, format_string, *data):
        self.pre_write_cb(command_name, *data)
        packet_format = ''.join(['<B', format_string])
        packed_struct = struct.pack(packet_format, command_name.value, *data)
        self._ser.write(packed_struct)
        self.post_write_cb(command_name, *data)

    def _read_packet(self, format_string):
        self.pre_read_cb()
        packet_format = ''.join(['<', format_string])
        num_bytes = struct.Struct(packet_format).size
        packet = self._ser.read(num_bytes)
        # Read failed either due to timeout or transmission error
        if len(packet) != num_bytes:
            print("Packet read failed")
            #raise # READ ERROR
        data = struct.unpack(packet_format, packet)
        self.post_read_cb(data)
        return data

    def _hash_command(self):
        self._write_packet(COMMANDS.${connection['hash_name']}, '')
        return self._read_packet('Q')[0]

