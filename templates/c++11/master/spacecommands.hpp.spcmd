/*
 * WARNING: This file is autogenerated by SpaceCommander
 *
 * Any changes will be overwritten!
 */
<%
    type_map = {
        'char': 'char',
        'int8': 'int8_t',
        'uint8': 'uint8_t',
        'int16': 'int16_t',
        'uint16':  'uint16_t',
        'int32': 'int32_t',
        'uint32': 'uint32_t',
        'int64': 'int64_t',
        'uint64': 'uint64_t',
        'float': 'float',
        'string': 'char*'
    }
    
    parity_map = {
        'none': '',
        'even': '',
        'odd': '',
    }

    size_map = {
        'char': 1,
        'int8': 1,
        'uint8': 1,
        'int16': 2,
        'uint16':  2,
        'int32': 4,
        'uint32': 4,
        'int64': 8,
        'uint64': 8,
        'float': 4,
        'string': 4
    }

    heartbeat_map = {
        'uint8': 1,
        'uint16': 2,
        'uint32': 3,
        'uint64': 4
    }
    
    if heartbeat is not None:
        max_write_size = heartbeat_map[heartbeat['size']]
    else:
        max_write_size = 0
      
    for command in commands:
        size = 0
        for arg in command['inputs']:
            size += size_map[arg['type']]
        max_write_size = max(max_write_size, size)
    
    # Start with hash size, heartbeat can never be bigger     
    max_read_size = 8
    for command in commands:
        size = 0
        for arg in command['outputs']:
            size += size_map[arg['type']]
        max_read_size = max(max_read_size, size)
%>
#ifndef SPACECOMMANDS_MASTER_HPP
#define SPACECOMMANDS_MASTER_HPP

// TODO Serial library
// #include serial
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <iostream>

namespace spcmd_master {

static const uint64_t master_hash = 0x${connection['hash']}ULL;

% for command in commands:
struct ${command['name']}_in {
  % for arg in command['inputs']:
  ${type_map[arg['type']]} ${arg['name']};
  % endfor
};
struct ${command['name']}_out {
  % for arg in command['outputs']:
  ${type_map[arg['type']]} ${arg['name']};
  % endfor
};

% endfor

// Callbacks
// --------------------------------------------------
void version_error(uint64_t received_hash);
// void pre_write_cb(COMMANDS command);
// void post_write_cb();
// void pre_read_cb();
// void post_read_cb();


enum COMMANDS : uint8_t {
    % if heartbeat is not None:
    ${heartbeat['NAME']} = ${heartbeat['index']},
    % endif
    ${connection['hash_name']} = ${connection['hash_index']},
    % for command in commands:
    ${command['NAME']} = ${command['index']},
    % endfor
};

template <typename T>
class Master {
public:
  Master() {}
  Master(T& serial);

  // User functions
  // --------------------------------------------------
  void begin();
  void close();
  bool test_hash();

  // Commands
  // --------------------------------------------------
  % for command in commands:
    /**************************************************
     * ${command['description']}
     % if len(command['inputs']) > 0:
     *
     * Inputs:
     % for input_arg in command['inputs']:
     * @param ${input_arg['name']} ${input_arg['description']}
     % endfor
     % endif
     % if len(command['outputs']) > 0:
     *
     * Outputs:
     * Struct of type ${command['name']}_out, which has the following
     * data members:
     % for output_arg in command['outputs']:
     * @param ${output_arg['name']} ${output_arg['description']}
     % endfor
     % endif
     **************************************************/
    ${command['name']}_out ${command['name']}(\
% for idx, arg in enumerate(command['inputs']):
${type_map[arg['type']]} ${arg['name']}\
% if idx < len(command['inputs']) - 1:
, \
% endif
% endfor
);
    
    % endfor

protected:
  struct write_buffer_t {
    COMMANDS command;
    uint8_t data[${max_write_size}];
  };
  struct read_buffer_t {
    uint8_t data[${max_read_size}];
  };
  // Internal functions
  // --------------------------------------------------
  void write_packet(const COMMANDS command, const uint8_t* bytes, const size_t len);
  void read_packet(uint8_t* bytes, const size_t len);
  uint64_t hash_command();

private:
  T* m_serial;
  write_buffer_t m_write_buffer;
  read_buffer_t m_read_buffer;
  % for command in commands:
  ${command['name']}_in m_${command['name']}_input_buffer;
  ${command['name']}_out m_${command['name']}_output_buffer;
  % endfor
};

// User functions
// --------------------------------------------------
template <typename T>
void Master<T>::begin() {
}

template <typename T>
void Master<T>::close() {
}

template <typename T>
bool Master<T>::test_hash() {
  uint64_t r_hash = hash_command();
  if (memcmp(&r_hash, &master_hash, 8) != 0) {
    version_error(r_hash);
    return false;
  }
  return true;
}


// Internal functions
// --------------------------------------------------
template <typename T>
Master<T>::Master(T& serial)
    : m_serial(&serial) {
  // m_write_buffer = write_buffer_t{};
  // m_${command['name']}_input_buffer = ${command['name']}_in{};
  // m_${command['name']}_output_buffer = ${command['name']}_out{};
}

template <typename T>
void Master<T>::write_packet(const COMMANDS command, const uint8_t* bytes, const size_t len) {
  m_write_buffer.command = command;
  memcpy(m_write_buffer.data, bytes, len);
  // Implement with proper serial code
  std::cout << "Write: " << m_write_buffer.command;
  for (size_t i=0; i < len; ++i) {
    std::cout << " (" << int(m_write_buffer.data[i]) << ')';
  }
  std::cout << std::endl;
}

template <typename T>
void Master<T>::read_packet(uint8_t* bytes, const size_t len) {
  // Implement with proper serial code
  if (len == 8) {
    memcpy(bytes, &master_hash, 8);
  }
  else {
    uint8_t b = 'a';
    memcpy(bytes, &b, 1);
  }
}
  
template <typename T>
uint64_t Master<T>::hash_command() {
  static uint64_t read_hash;
  write_packet(COMMANDS::${connection['hash_name']}, nullptr, 0);
  read_packet(reinterpret_cast<uint8_t*>(&read_hash), 8);
  return read_hash;
}

// Commands
// --------------------------------------------------
% for command in commands:

template <typename T>
${command['name']}_out Master<T>::${command['name']}(\
% for input_idx, input_arg in enumerate(command['inputs']):
${type_map[input_arg['type']]} ${input_arg['name']}\
% if input_idx < len(command['inputs']) - 1:
, \
% endif
% endfor
) {
  // EMPTY STRUCTS STILL HAVE SIZE 1!!!!!
  % for input_arg in command['inputs']:
  m_${command['name']}_input_buffer.${input_arg['name']} = ${input_arg['name']};
  % endfor
  write_packet(COMMANDS::${command['NAME']}, reinterpret_cast<uint8_t*>(&m_${command['name']}_input_buffer), sizeof(m_${command['name']}_input_buffer));
  read_packet(reinterpret_cast<uint8_t*>(&m_${command['name']}_output_buffer), sizeof(m_${command['name']}_output_buffer));
  return m_${command['name']}_output_buffer;
} 

% endfor

} // namespace spcmds


#endif // SPACECOMMANDS_HOST_HPP
