/*
 * WARNING: This file is autogenerated by SpaceCommander
 *
 * Any changes will be overwritten!
 */
<%
    type_map = {
        'char': 'char',
        'int8': 'int8_t',
        'uint8': 'uint8_t',
        'int16': 'int16_t',
        'uint16':  'uint16_t',
        'int32': 'int32_t',
        'uint32': 'uint32_t',
        'int64': 'int64_t',
        'uint64': 'uint64_t',
        'float': 'float',
        'string': 'char*'
    }
    
    parity_map = {
        'none': '',
        'even': '',
        'odd': '',
    }

    size_map = {
        'char': 1,
        'int8': 1,
        'uint8': 1,
        'int16': 2,
        'uint16':  2,
        'int32': 4,
        'uint32': 4,
        'int64': 8,
        'uint64': 8,
        'float': 4,
        'string': 4
    }

    heartbeat_map = {
        'uint8': 1,
        'uint16': 2,
        'uint32': 3,
        'uint64': 4
    }
    # Start with hash size, heartbeat can never be bigger     
    max_write_size = 8
    for command in commands:
        size = 0
        for arg in command['outputs']:
            size += size_map[arg['type']]
        max_write_size = max(max_write_size, size)
    
    if heartbeat is not None:
        max_read_size = heartbeat_map[heartbeat['size']]
    else:
        max_read_size = 0
    for command in commands:
        size = 0
        for arg in command['inputs']:
            size += size_map[arg['type']]
        max_read_size = max(max_read_size, size)
%>
#ifndef SPACECOMMANDS_SLAVE_HPP
#define SPACECOMMANDS_SLAVE_HPP

// TODO Serial library
// #include serial
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <iostream>

namespace spcmd_slave {

static const uint64_t slave_hash = 0x${connection['hash']}ULL;


// Command Data Structs
% for command in commands:
struct ${command['name']}_in {
  % for arg in command['outputs']:
  ${type_map[arg['type']]} ${arg['name']};
% endfor
};
struct ${command['name']}_out {
  % for arg in command['inputs']:
  ${type_map[arg['type']]} ${arg['name']};
  % endfor
};
  
% endfor

// --------------------------------------------------
% for command in commands:
/**************************************************
 * ${command['description']}
 % if len(command['outputs']) > 0:
 *
 * Inputs:
 % for arg in command['outputs']:
 * @param ${arg['name']} ${arg['description']}
 % endfor
 % endif
 % if len(command['inputs']) > 0:
 *
 * Outputs:
 * Struct of type ${command['name']}_out, which has the following
 * data members:
 % for arg in command['inputs']:
 * @param ${arg['name']} ${arg['description']}
 % endfor
 % endif
 **************************************************/
${command['name']}_out ${command['name']}_cb(\
% for idx, arg in enumerate(command['outputs']):
${type_map[arg['type']]} ${arg['name']}\
% if idx < len(command['outputs']) - 1:
, \
% endif
% endfor
);

% endfor
  
// Callbacks
// --------------------------------------------------
// void pre_write_cb();
// void post_write_cb();
// void pre_read_cb();
// void post_read_cb();
// Commands


enum COMMANDS : uint8_t {
    % if heartbeat is not None:
    ${heartbeat['NAME']} = ${heartbeat['index']},
    % endif
    ${connection['hash_name']} = ${connection['hash_index']},
    % for command in commands:
    ${command['NAME']} = ${command['index']},
    % endfor
};

template <typename T>
class Slave {
public:

  Slave() {}
  Slave(T& serial);

  // User functions
  // --------------------------------------------------
  void begin();
  void close();
  bool update();

protected:
  struct write_buffer_t{
    uint8_t data[${max_write_size}];
  };
  struct read_buffer_t {
    uint8_t data[${max_read_size}];
  };
  // Internal functions
  // --------------------------------------------------
  void write_packet(const uint8_t* bytes, const size_t len);
  void read_packet(uint8_t* bytes, const size_t len);
  void hash_command();

  % for command in commands:
  void ${command['name']}();
  % endfor
  
private:
  T* m_serial;
  write_buffer_t m_write_buffer;
  read_buffer_t m_read_buffer;
  % for command in commands:
  ${command['name']}_in m_${command['name']}_input_buffer;
  ${command['name']}_out m_${command['name']}_output_buffer;
  % endfor
};


// Internal functions
// --------------------------------------------------
template <typename T>
Slave<T>::Slave(T& serial)
    : m_serial(&serial) {
}

template <typename T>
void Slave<T>::write_packet(const uint8_t* bytes, const size_t len) {
  memcpy(m_write_buffer.data, bytes, len);
  // Implement with proper serial code
  std::cout << "Write: ";
  for (size_t i=0; i < len; ++i) {
    std::cout << " (" << int(m_write_buffer.data[i]) << ')';
  }
  std::cout << std::endl;
}

template <typename T>
void Slave<T>::read_packet(uint8_t* bytes, const size_t len) {
  // Implement with proper serial code
  if (len == 1) {
    uint8_t a = 'a';
    memcpy(bytes, &a, 1);
  }
  if (len == 4) {
    uint32_t b = 0;
    b |= 1 << 24;
    b |= 2 << 16;
    b |= 3 << 8;
    b |= 4;
    memcpy(bytes, &b, 4);
  }
}

template <typename T>
void Slave<T>::hash_command() {
  write_packet(reinterpret_cast<const uint8_t*>(&slave_hash), 8);
}

template <typename T>
bool Slave<T>::update() {
  //if (Serial.available() > 0) {
  // Replace with serial read
  static uint8_t i = 0;
  COMMANDS command = static_cast<COMMANDS>(i);
  ++i;
  // Switch to function table lookup
  switch(command) {
  % if heartbeat is not None:
  case COMMANDS::${heartbeat['NAME']}:
    //heartbeat();
    break;
  % endif
  case COMMANDS::${connection['hash_name']}:
    hash_command();
    break;
  % for command in commands:
  case COMMANDS::${command['NAME']}:
    ${command['name']}();
    break;
  % endfor
  default:
    return false;
  }
  return true;
}


% for command in commands:
template <typename T>
void Slave<T>::${command['name']}() {
  read_packet(reinterpret_cast<uint8_t*>(&m_${command['name']}_input_buffer), sizeof(m_${command['name']}_input_buffer));
  m_${command['name']}_output_buffer = ${command['name']}_cb(\
% for idx, arg in enumerate(command['outputs']):
m_${command['name']}_input_buffer.${arg['name']}\
% if idx < len(command['outputs']) - 1:
, \
% endif
% endfor
);
  write_packet(reinterpret_cast<uint8_t*>(&m_${command['name']}_output_buffer), sizeof(m_${command['name']}_output_buffer));
}

% endfor

} // namespace spcmds

#endif // SPACECOMMANDS_HPP
