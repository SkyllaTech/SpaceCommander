'''
 WARNING: This file is autogenerated by SpaceCommander

 Any changes will be overwritten!
'''

import struct
import serial
import time
from enum import Enum
<%
    import struct
    type_map = {
        'char': 'c',
        'int8': 'b',
        'uint8': 'B',
        'int16': 'h',
        'uint16':  'H',
        'int32': 'i',
        'uint32': 'I',
        'int64': 'q',
        'uint64': 'Q',
        'float': 'f',
        'string': 'p'
    }
    
    parity_map = {
        'none': 'serial.PARITY_NONE',
        'even': 'serial.PARITY_EVEN',
        'odd': 'serial.PARITY_ODD',
    }

    heartbeat_map = {
        'uint8': 8,
        'uint16': 16,
        'uint32': 32,
        'uint64': 64
    }
%>

class COMMANDS(Enum):
    % if heartbeat is not None:
    ${heartbeat['NAME']} = ${heartbeat['index']}
    % endif
    ${connection['hash_name']} = ${connection['hash_index']}
    % for command in commands:
    ${command['NAME']} = ${command['index']}
    % endfor


class SlaveBase:
    def __init__(self, port):
        self._ser = serial.serial_for_url(port,
                                          baudrate=${connection['speed']},
                                          parity=${parity_map[connection['parity']]},
                                          % if 'timeout' in slave:
                                          timeout=${slave['timeout']},
                                          % endif
                                          do_not_open=True)

        self._commands = {
            % if heartbeat is not None:
            COMMANDS.${heartbeat['NAME']}: self._heartbeat_command,
            % endif
            COMMANDS.${connection['hash_name']}: self._hash_command,
            % for command in commands:
            COMMANDS.${command['NAME']}: self._${command['name']},
            % endfor
        }
        % if heartbeat is not None:
        self._heartbeat_count = 0
        self._heartbeat_max = 1 << ${heartbeat_map[heartbeat['size']]}
        % endif

    # User functions
    # --------------------------------------------------
    def begin(self):
        self._ser.open()
            
    def close(self):
        self._ser.close()

    def process_commands(self):
        if self._ser.in_waiting > 0:
            command_byte = self._ser.read(1)
            command_value = struct.unpack('<B', command_byte)
            command = COMMANDS(command_value[0])
            self._commands.get(command, self._bad_command)()

    # Callbacks
    # --------------------------------------------------
    # Callback called before initiating a write to master
    def pre_write_cb(self, *data):
        pass

    # Callback called after finishing a write to master
    def post_write_cb(self, *data):
        pass

    # Callback called before initiating a read from master
    def pre_read_cb(self):
        pass

    # Callback called after finishing a read from master
    def post_read_cb(self, *data):
        pass
    
    # Command callbacks
    # --------------------------------------------------
    % for command in commands:
    def ${command['name']}_cb(self\
% for output_arg in command['outputs']:
, ${output_arg['name']}\
% endfor
):
        """
        ${command['description']}
        % if len(command['outputs']) > 0:
        
        Arguments:
        % for output in command['outputs']:
        ${output['name']} (${output['type']}) -- ${output['description']}
        % endfor
        % endif
        % if len(command['inputs']) > 0:

        Returns:
        % for input in command['inputs']:
        ${input['name']} (${input['type']}) -- ${input['description']}
        % endfor
        % endif
        """
        pass

    % endfor

    # Internal functions
    # --------------------------------------------------
    def _write_packet(self, format_string, *data):
        self.pre_write_cb(*data)
        packet_format = ''.join(['<', format_string])
        packed_struct = struct.pack(packet_format, *data)
        self._ser.write(packed_struct)
        self.post_write_cb(*data)

    def _read_packet(self, format_string):
        self.pre_read_cb()
        packet_format = ''.join(['<', format_string])
        num_bytes = struct.Struct(packet_format).size
        packet = self._ser.read(num_bytes)
        # Read failed either due to timeout or transmission error
        if len(packet) != num_bytes:
            print("Packet read failed")
            #raise # READ ERROR
        data = struct.unpack(packet_format, packet)
        self.post_read_cb(data)
        return data

    def _bad_command(self):
        pass
    
    % if heartbeat is not None:
    def _heartbeat_command(self):
        self._write_packet('${type_map[heartbeat['size']]}', self._heartbeat_count)
    % endif

    def _hash_command(self):
        self._write_packet('Q', 0x${connection['hash']})

    % for command in commands:
    def _${command['name']}(self):
        % if len(command['inputs']) > 0:
        ret_read = self._read_packet('${''.join([type_map[i['type']] for i in command['inputs']])}')
        ret_cb = self.${command['name']}_cb(*ret_read)
        % else:
        ret_cb = self.${command['name']}_cb()
        % endif
        % if len(command['outputs']) > 0:
        self._write_packet('${''.join([type_map[o['type']] for o in command['outputs']])}', ret_cb)
        % else:
        self._write_packet('')
        % endif

    % endfor
