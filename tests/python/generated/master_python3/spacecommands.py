
'''
 WARNING: This file is autogenerated by SpaceCommander

 Any changes will be overwritten!
'''

import struct
import serial
import time
from enum import Enum
import crcmod.predefined
crc_func = crcmod.predefined.mkCrcFun('crc-32')
crc_format = 'I'
crc_size = struct.calcsize(crc_format)
# Command format
command_format = 'B'
command_size = struct.calcsize(command_format)
# Ack format
ack_format = '?'
ack_size = struct.calcsize(ack_format)
# Address format
address_format = 'B'
address_size = struct.calcsize(address_format)

class COMMANDS(Enum):
    SPCMD_HASH = 0
    SPCMD_COMMAND_SEND_BYTE = 1
    SPCMD_COMMAND_RECV_BYTE = 2
    SPCMD_COMMAND_ECHO = 3


class MasterBase:
    def __init__(self, port):
        self._ser = serial.serial_for_url(port,
                                          baudrate=9600,
                                          parity=serial.PARITY_NONE,
                                          timeout=(1000 / 1000),
                                          do_not_open=True)

    # User functions
    # --------------------------------------------------
    def begin(self):
        self._ser.open()

    def close(self):
        self._ser.close()

    def test_hash(self, address):
        hash_val = self._hash_command(address)
        if hash_val != 0xbae9e55c59b25347:
            print('Hash Mismatch! Received hash {} but expected {}. Ensure both host and device are the same version.'.format(hex(hash_val), b'bae9e55c59b25347'.upper()))
            return False
        return True

    def get_hash(self, address):
        return self._hash_command(address)

    # Callbacks
    # --------------------------------------------------
    # Callback called before initiating a write to a slave
    def pre_write_cb(self):
        pass

    # Callback called after finishing a write to a slave
    def post_write_cb(self):
        pass

    # Callback called before initiating a read from a slave
    def pre_read_cb(self):
        pass

    # Callback called after finishing a read from a slave
    def post_read_cb(self):
        pass

    # Callback called when no response is received
    def read_no_response_cb(self):
        pass

    # Callback called when the address in the response does not match
    def read_address_mismatch_cb(self):
        pass

    # Callback called when a read size fails
    def read_size_fail_cb(self):
        pass

    # Callback called when a CRC fails
    def read_crc_fail_cb(self):
        pass

    # Callback called when a NACK is received
    def read_nack_cb(self):
        pass

    # Commands
    # --------------------------------------------------
    def send_byte(self, address, b):
        """
        Send a byte to the slave

        Arguments:
        address -- Slave address
        b (uint8) -- Byte to be sent
        """
        self._write_packet(address, COMMANDS.SPCMD_COMMAND_SEND_BYTE, 'B', b)
        ret_read = self._read_packet(address, '')

    def recv_byte(self, address):
        """
        Receive a byte from the slave

        Returns:
        b (uint8) -- Received byte
        """
        self._write_packet(address, COMMANDS.SPCMD_COMMAND_RECV_BYTE, '')
        ret_read = self._read_packet(address, 'B')
        if ret_read[0]:
            return ret_read[1][0]
        else:
            return None

    def echo(self, address, send_string):
        """
        Send string to slave and read it back

        Arguments:
        address -- Slave address
        send_string (char) -- No description provided

        Returns:
        recv_string (char) -- No description provided
        """
        self._write_packet(address, COMMANDS.SPCMD_COMMAND_ECHO, 'c', send_string.encode('ascii'))
        ret_read = self._read_packet(address, 'c')
        if ret_read[0]:
            return ret_read[1][0]
        else:
            return None

    # Internal functions
    # --------------------------------------------------
    def _write_packet(self, address, command_name, data_format, *data):
        # Pre write callback
        self.pre_write_cb()
        # Full packet format string
        packet_format = ''.join(['<', address_format, command_format, data_format, crc_format])
        # Packet buffer
        packet_size = struct.calcsize(packet_format)
        packet_buffer = bytearray(packet_size)

        # Pack address
        struct.pack_into('<' + address_format, packet_buffer, 0, address)
        # Pack command
        struct.pack_into('<' + command_format, packet_buffer, 0 + address_size, command_name.value)
        # Pack data
        struct.pack_into('<' + data_format, packet_buffer, command_size + address_size, *data)
        # Calculate CRC
        crc = crc_func(packet_buffer[0:(packet_size - crc_size)]) # CRC is always last bytes
        struct.pack_into('<' + crc_format, packet_buffer, (packet_size - crc_size), crc)

        # print("Write")
        # print(packet_size)
        # print(packet_buffer)
        # Write buffer to serial
        self._ser.write(packet_buffer)
        # Post write callback
        self.post_write_cb()

    def _read_packet(self, address, data_format):
        # Pre read callback
        self.pre_read_cb()
        # Full packet format string
        packet_format = ''.join(['<', address_format, ack_format, data_format, crc_format])
        # print(packet_format)
        # Packet buffer
        packet_size = struct.calcsize(packet_format)
        packet_buffer = self._ser.read(packet_size)
        data_size = packet_size - address_size - ack_size - crc_size

        if len(packet_buffer) < 1:
            print("No response!")
            self.read_no_response_cb()
            return False, None

        # Unpack address
        sent_address = struct.unpack_from('<' + address_format, packet_buffer, 0)[0]
        if sent_address != address:
            print("Packet address does not match!")
            self.read_address_mismatch_cb()
            return False, None
        
        # Unpack ACK
        ack = struct.unpack_from('<' + ack_format, packet_buffer, 0 + address_size)
        if not ack[0]:
            print("Packet NACK'd!")
            self.read_nack_cb()
            return False, None

        # print("Read")
        # print(packet_size)
        # print(packet_buffer)
        # Read failed either due to timeout or transmission error
        if len(packet_buffer) != packet_size:
            print("Packet read size failed!")
            self.read_size_fail_cb()
            return False, None

        # Unpack CRC and test
        sent_crc = struct.unpack_from('<' + crc_format, packet_buffer, (packet_size - crc_size))[0]
        calc_crc = crc_func(packet_buffer[0:(packet_size - crc_size)]) # CRC is always last bytes
        # print(hex(sent_crc))
        # print(hex(calc_crc))
        if sent_crc != calc_crc:
            print("Packet CRC failed!")
            self.read_crc_fail_cb()
            return False, None

        # Unpack data
        data = struct.unpack_from('<' + data_format, packet_buffer, ack_size + address_size)
        # Post read callback
        self.post_read_cb()
        return True, data

    def _hash_command(self, address):
        self._write_packet(address, COMMANDS.SPCMD_HASH, '')
        ret_read = self._read_packet(address, 'Q')
        if ret_read[0]:
            return ret_read[1][0]
        else:
            return 0
