
'''
 WARNING: This file is autogenerated by SpaceCommander

 Any changes will be overwritten!
'''

import struct
import serial
import time
from enum import Enum
import crcmod.predefined
crc_func = crcmod.predefined.mkCrcFun('crc-32')
crc_format = 'I'
crc_size = struct.calcsize(crc_format)
# Command format
command_format = 'B'
command_size = struct.calcsize(command_format)
# Ack format
ack_format = '?'
ack_size = struct.calcsize(ack_format)
# Address format
address_format = 'B'
address_size = struct.calcsize(address_format)

class COMMANDS(Enum):
    SPCMD_HASH = 0
    SPCMD_COMMAND_SEND_BYTE = 1
    SPCMD_COMMAND_RECV_BYTE = 2
    SPCMD_COMMAND_ECHO = 3


class SlaveBase:
    def __init__(self, port, address):
        self._ser = serial.serial_for_url(port,
                                          baudrate=9600,
                                          parity=serial.PARITY_NONE,
                                          timeout=(1000 / 1000),
                                          do_not_open=True)
        self.address = address
        self._commands = {
            COMMANDS.SPCMD_HASH: self._hash_command,
            COMMANDS.SPCMD_COMMAND_SEND_BYTE: self._send_byte,
            COMMANDS.SPCMD_COMMAND_RECV_BYTE: self._recv_byte,
            COMMANDS.SPCMD_COMMAND_ECHO: self._echo,
        }

    # User functions
    # --------------------------------------------------
    def begin(self):
        self._ser.open()

    def close(self):
        self._ser.close()

    def process_commands(self):
        if self._ser.in_waiting > 0:
            address_byte = self._ser.read(address_size)
            address = struct.unpack('<' + address_format, address_byte)[0]
            if address != self.address:
                # Wait until we stop receiving bytes to start reading again
                time.sleep(2 * 8 / 9600)
                while self._ser.in_waiting > 0:
                    # Dump input buffer
                    self._ser.reset_input_buffer()
                    time.sleep(2 * 8 / 9600)
                # Dump input buffer
                self._ser.reset_input_buffer()
                return
            command_byte = self._ser.read(command_size)
            command_value = struct.unpack('<' + command_format, command_byte)
            command = COMMANDS(command_value[0])
            self._commands.get(command, self.command_error_cb)()
        # Yield thread
        time.sleep(0)

    # Callbacks
    # --------------------------------------------------
    # Callback called before initiating a write to master
    def pre_write_cb(self):
        pass

    # Callback called after finishing a write to master
    def post_write_cb(self):
        pass

    # Callback called before initiating a read from master
    def pre_read_cb(self):
        pass

    # Callback called after finishing a read from master
    def post_read_cb(self):
        pass

    # Callback called if a command received is not valid
    def command_error_cb(self):
        pass

    # Callback called when a read size fails
    def read_size_fail_cb(self):
        pass

    # Callback called when a CRC fails
    def read_crc_fail_cb(self):
        pass

    # Command callbacks
    # --------------------------------------------------
    def send_byte_cb(self):
        """
        Send a byte to the slave

        Returns:
        b (uint8) -- Byte to be sent
        """
        pass

    def recv_byte_cb(self, b):
        """
        Receive a byte from the slave

        Arguments:
        b (uint8) -- Received byte
        """
        pass

    def echo_cb(self, recv_string):
        """
        Send string to slave and read it back

        Arguments:
        recv_string (char) -- No description provided

        Returns:
        send_string (char) -- No description provided
        """
        pass


    # Internal functions
    # --------------------------------------------------
    def _write_packet(self, ack, data_format, *data):
        # Pre write callback
        self.pre_write_cb()
        # Full packet format string
        packet_format = ''.join(['<', address_format, ack_format, data_format, crc_format])
        # Packet buffer
        packet_size = struct.calcsize(packet_format)
        packet_buffer = bytearray(packet_size)

        # Pack address
        struct.pack_into('<' + address_format, packet_buffer, 0, self.address)
        # Pack ACK
        struct.pack_into('<' + ack_format, packet_buffer, 0 + address_size, ack)
        # Pack data
        data = tuple(d.encode('ascii') if isinstance(d, str) else d for d in data)
        struct.pack_into('<' + data_format, packet_buffer, ack_size + address_size, *data)
        # Calculate CRC
        crc = crc_func(packet_buffer[0:(packet_size - crc_size)]) # CRC is always last bytes
        struct.pack_into('<' + crc_format, packet_buffer, (packet_size - crc_size), crc)

        # Write buffer to serial
        self._ser.write(packet_buffer)
        # Post write callback
        self.post_write_cb()

    def _read_packet(self, command, data_format):
        # Pre read callback
        self.pre_read_cb()
        # Full packet format string
        packet_format = ''.join(['<', address_format, command_format, data_format, crc_format])
        # Packet buffer
        packet_size = struct.calcsize(packet_format)
        packet_buffer = bytearray(packet_size)
        # Pack address into buffer to reconstruct full packet
        struct.pack_into('<' + address_format, packet_buffer, 0, self.address)
        # Pack read command into buffer to reconstruct full packet
        struct.pack_into('<' + command_format, packet_buffer, 0 + address_size, command.value)
        # Pack read data into buffer
        packet = self._ser.read(packet_size - address_size - command_size)
        data_size = packet_size - address_size - command_size - crc_size

        # Read failed either due to timeout or transmission error
        if len(packet) != packet_size - address_size - command_size:
            print("Packet read size failed")
            self.read_size_fail_cb()
            return False, None

        # Copy packet into buffer
        packet_buffer[command_size + address_size:command_size + data_size + address_size] = packet
        # Unpack CRC and test
        sent_crc = struct.unpack_from('<' + crc_format, packet_buffer, (packet_size - crc_size))[0]
        calc_crc = crc_func(packet_buffer[0:(packet_size - crc_size)]) # CRC is always last bytes

        if sent_crc != calc_crc:
            print("Packet CRC failed!")
            self.read_crc_fail_cb()
            return False, None

        # Unpack data
        data = struct.unpack_from('<' + data_format, packet_buffer, command_size + address_size)
        # Post read callback
        self.post_read_cb()
        return True, data

    def _hash_command(self):
        ret_read = self._read_packet(COMMANDS.SPCMD_HASH, '')
        if ret_read[0]:
            self._write_packet(True, 'Q', 0xbae9e55c59b25347)
        else:
            self._write_packet(False, '')

    def _send_byte(self):
        ret_read = self._read_packet(COMMANDS.SPCMD_COMMAND_SEND_BYTE, 'B')
        if ret_read[0]:
            self.send_byte_cb(*ret_read[1])
            self._write_packet(True, '')
        else:
            self._write_packet(False, '')

    def _recv_byte(self):
        ret_read = self._read_packet(COMMANDS.SPCMD_COMMAND_RECV_BYTE, '')
        if ret_read[0]:
            ret_cb = self.recv_byte_cb()
            self._write_packet(True, 'B', ret_cb)

    def _echo(self):
        ret_read = self._read_packet(COMMANDS.SPCMD_COMMAND_ECHO, 'c')
        if ret_read[0]:
            ret_cb = self.echo_cb(*ret_read[1])
            self._write_packet(True, 'c', ret_cb)
