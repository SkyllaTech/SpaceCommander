/*
 * WARNING: This file is autogenerated by SpaceCommander
 *
 * Any changes will be overwritten!
 */

#ifndef SPACECOMMANDS_SLAVE_HPP
#define SPACECOMMANDS_SLAVE_HPP

#include <Arduino.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include "test.h"

namespace spcmd_slave {

static const uint64_t slave_hash = 0xdc39f56cc60a9f0fULL;


  


// Callbacks
// --------------------------------------------------
// void pre_write_cb();
// void post_write_cb();
// void pre_read_cb();
// void post_read_cb();
// Commands


enum COMMANDS : uint8_t {
    SPCMD_HEARTBEAT = 0,
    SPCMD_HASH = 1,
    SPCMD_COMMAND_SEND_BYTE = 2,
    SPCMD_COMMAND_RECV_BYTE = 3,
    SPCMD_COMMAND_ECHO = 4,
    SPCMD_COMMAND_BIGTEST = 5,
};

template <typename T>
class Slave {
public:

  Slave() {}
  Slave(T& serial);

  // User functions
  // --------------------------------------------------
  void begin();
  void close();
  bool update();

protected:
  struct write_buffer_t{
    uint8_t data[8];
  };
  struct read_buffer_t {
    uint8_t data[8];
  };
  // Internal functions
  // --------------------------------------------------
  void write_packet(const uint8_t* bytes, const size_t len);
  void read_packet(uint8_t* bytes, const size_t len);
  void hash_command();

  void send_byte();
  void recv_byte();
  void echo();
  void bigtest();
  
private:
  T* m_serial;
  write_buffer_t m_write_buffer;
  read_buffer_t m_read_buffer;
  send_byte_in m_send_byte_input_buffer;
  send_byte_out m_send_byte_output_buffer;
  recv_byte_in m_recv_byte_input_buffer;
  recv_byte_out m_recv_byte_output_buffer;
  echo_in m_echo_input_buffer;
  echo_out m_echo_output_buffer;
  bigtest_in m_bigtest_input_buffer;
  bigtest_out m_bigtest_output_buffer;
};

// User functions
// --------------------------------------------------
template <typename T>
Slave<T>::Slave(T& serial)
    : m_serial(&serial) {
}

template <typename T>
void Slave<T>::begin(){
  m_serial->begin(9600);
  m_serial->flush();
}
  
template <typename T>
void Slave<T>::close(){
  m_serial->end();
} 
  
template <typename T>
bool Slave<T>::update() {
  if (m_serial->available() > 0) {
    COMMANDS command;
    m_serial->readBytes(reinterpret_cast<uint8_t*>(&command), 1);
    // Switch to function table lookup
    switch(command) {
    case COMMANDS::SPCMD_HEARTBEAT:
      //heartbeat();
      break;
    case COMMANDS::SPCMD_HASH:
      hash_command();
      break;
    case COMMANDS::SPCMD_COMMAND_SEND_BYTE:
      send_byte();
      break;
    case COMMANDS::SPCMD_COMMAND_RECV_BYTE:
      recv_byte();
      break;
    case COMMANDS::SPCMD_COMMAND_ECHO:
      echo();
      break;
    case COMMANDS::SPCMD_COMMAND_BIGTEST:
      bigtest();
      break;
    default:
      return false;
    }
  }
  return true;
}

// Internal functions
// --------------------------------------------------
template <typename T>
void Slave<T>::write_packet(const uint8_t* bytes, const size_t len) {
  memcpy(m_write_buffer.data, bytes, len);
  m_serial->write(reinterpret_cast<const uint8_t*>(&m_write_buffer), sizeof(m_write_buffer));
}

template <typename T>
void Slave<T>::read_packet(uint8_t* bytes, const size_t len) {
  m_serial->readBytes(reinterpret_cast<uint8_t*>(&m_read_buffer), sizeof(m_read_buffer));
  memcpy(bytes, m_read_buffer.data, len);
}

template <typename T>
void Slave<T>::hash_command() {
  write_packet(reinterpret_cast<const uint8_t*>(&slave_hash), 8);
}

template <typename T>
void Slave<T>::send_byte() {
  read_packet(reinterpret_cast<uint8_t*>(&m_send_byte_input_buffer), sizeof(m_send_byte_input_buffer));
  m_send_byte_output_buffer = send_byte_cb();

  write_packet(reinterpret_cast<uint8_t*>(&m_send_byte_output_buffer), 0);
}

template <typename T>
void Slave<T>::recv_byte() {
  read_packet(reinterpret_cast<uint8_t*>(&m_recv_byte_input_buffer), sizeof(m_recv_byte_input_buffer));
  m_recv_byte_output_buffer = recv_byte_cb(m_recv_byte_input_buffer.b);

  write_packet(reinterpret_cast<uint8_t*>(&m_recv_byte_output_buffer), 0);
}

template <typename T>
void Slave<T>::echo() {
  read_packet(reinterpret_cast<uint8_t*>(&m_echo_input_buffer), sizeof(m_echo_input_buffer));
  m_echo_output_buffer = echo_cb(m_echo_input_buffer.recv);

  write_packet(reinterpret_cast<uint8_t*>(&m_echo_output_buffer), sizeof(m_echo_output_buffer));
}

template <typename T>
void Slave<T>::bigtest() {
  read_packet(reinterpret_cast<uint8_t*>(&m_bigtest_input_buffer), sizeof(m_bigtest_input_buffer));
  m_bigtest_output_buffer = bigtest_cb(m_bigtest_input_buffer.b3);

  write_packet(reinterpret_cast<uint8_t*>(&m_bigtest_output_buffer), sizeof(m_bigtest_output_buffer));
}


} // namespace spcmds

#endif // SPACECOMMANDS_HPP
