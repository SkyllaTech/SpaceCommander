/*
 * WARNING: This file is autogenerated by SpaceCommander
 *
 * Any changes will be overwritten!
 */

#ifndef SPACECOMMANDS_MASTER_HPP
#define SPACECOMMANDS_MASTER_HPP

// TODO Serial library
// #include serial
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <iostream>

namespace spcmd_master {

static const uint64_t master_hash = 0x40419b8b99b1c6e8ull;

struct send_byte_in {
  uint8_t b;
};
struct send_byte_out {
};

struct recv_byte_in {
};
struct recv_byte_out {
  uint8_t b;
};

struct echo_in {
  uint32_t send;
};
struct echo_out {
  uint32_t recv;
};

struct bigtest_in {
  uint32_t b1;
  uint32_t b2;
};
struct bigtest_out {
  uint32_t b3;
};


// Callbacks
// --------------------------------------------------
void version_error(uint64_t received_hash);
// void pre_write_cb(COMMANDS command);
// void post_write_cb();
// void pre_read_cb();
// void post_read_cb();


enum COMMANDS : uint8_t {
    SPCMD_HEARTBEAT = 0,
    SPCMD_HASH = 1,
    SPCMD_COMMAND_SEND_BYTE = 2,
    SPCMD_COMMAND_RECV_BYTE = 3,
    SPCMD_COMMAND_ECHO = 4,
    SPCMD_COMMAND_BIGTEST = 5,
};

template <typename T>
class Master {
public:
  Master() {}
  Master(T& serial);

  // User functions
  // --------------------------------------------------
  void begin();
  void close();
  bool test_hash();

  // Commands
  // --------------------------------------------------
    /**************************************************
     * Send a byte to the slave
     *
     * Inputs:
     * @param b Byte to be sent
     **************************************************/
    send_byte_out send_byte(uint8_t b);
    
    /**************************************************
     * Receive a byte from the slave
     *
     * Outputs:
     * Struct of type recv_byte_out, which has the following
     * data members:
     * @param b Received byte
     **************************************************/
    recv_byte_out recv_byte();
    
    /**************************************************
     * Send string to slave and read it back
     *
     * Inputs:
     * @param send No description provided
     *
     * Outputs:
     * Struct of type echo_out, which has the following
     * data members:
     * @param recv No description provided
     **************************************************/
    echo_out echo(uint32_t send);
    
    /**************************************************
     * No description provided
     *
     * Inputs:
     * @param b1 No description provided
     * @param b2 No description provided
     *
     * Outputs:
     * Struct of type bigtest_out, which has the following
     * data members:
     * @param b3 No description provided
     **************************************************/
    bigtest_out bigtest(uint32_t b1, uint32_t b2);
    

protected:
  struct write_buffer_t {
    COMMANDS command;
    uint8_t data[8];
  };
  struct read_buffer_t {
    uint8_t data[8];
  };
  // Internal functions
  // --------------------------------------------------
  void write_packet(const COMMANDS command, const uint8_t* bytes, const size_t len);
  void read_packet(uint8_t* bytes, const size_t len);
  uint64_t hash_command();

private:
  T* m_serial;
  write_buffer_t m_write_buffer;
  read_buffer_t m_read_buffer;
  send_byte_in m_send_byte_input_buffer;
  send_byte_out m_send_byte_output_buffer;
  recv_byte_in m_recv_byte_input_buffer;
  recv_byte_out m_recv_byte_output_buffer;
  echo_in m_echo_input_buffer;
  echo_out m_echo_output_buffer;
  bigtest_in m_bigtest_input_buffer;
  bigtest_out m_bigtest_output_buffer;
};

// User functions
// --------------------------------------------------
template <typename T>
void Master<T>::begin() {
}

template <typename T>
void Master<T>::close() {
}

template <typename T>
bool Master<T>::test_hash() {
  uint64_t r_hash = hash_command();
  if (memcmp(&r_hash, &master_hash, 8) != 0) {
    version_error(r_hash);
    return false;
  }
  return true;
}


// Internal functions
// --------------------------------------------------
template <typename T>
Master<T>::Master(T& serial)
    : m_serial(&serial) {
  // m_write_buffer = write_buffer_t{};
  // m_bigtest_input_buffer = bigtest_in{};
  // m_bigtest_output_buffer = bigtest_out{};
}

template <typename T>
void Master<T>::write_packet(const COMMANDS command, const uint8_t* bytes, const size_t len) {
  m_write_buffer.command = command;
  memcpy(m_write_buffer.data, bytes, len);
  // Implement with proper serial code
  std::cout << "Write: " << m_write_buffer.command;
  for (size_t i=0; i < len; ++i) {
    std::cout << " (" << int(m_write_buffer.data[i]) << ')';
  }
  std::cout << std::endl;
}

template <typename T>
void Master<T>::read_packet(uint8_t* bytes, const size_t len) {
  // Implement with proper serial code
  if (len == 8) {
    memcpy(bytes, &master_hash, 8);
  }
  else {
    uint8_t b = 'a';
    memcpy(bytes, &b, 1);
  }
}
  
template <typename T>
uint64_t Master<T>::hash_command() {
  static uint64_t read_hash;
  write_packet(COMMANDS::SPCMD_HASH, nullptr, 0);
  read_packet(reinterpret_cast<uint8_t*>(&read_hash), 8);
  return read_hash;
}

// Commands
// --------------------------------------------------

template <typename T>
send_byte_out Master<T>::send_byte(uint8_t b) {
  // EMPTY STRUCTS STILL HAVE SIZE 1!!!!!
  m_send_byte_input_buffer.b = b;
  write_packet(COMMANDS::SPCMD_COMMAND_SEND_BYTE, reinterpret_cast<uint8_t*>(&m_send_byte_input_buffer), sizeof(m_send_byte_input_buffer));
  read_packet(reinterpret_cast<uint8_t*>(&m_send_byte_output_buffer), sizeof(m_send_byte_output_buffer));
  return m_send_byte_output_buffer;
} 


template <typename T>
recv_byte_out Master<T>::recv_byte() {
  // EMPTY STRUCTS STILL HAVE SIZE 1!!!!!
  write_packet(COMMANDS::SPCMD_COMMAND_RECV_BYTE, reinterpret_cast<uint8_t*>(&m_recv_byte_input_buffer), sizeof(m_recv_byte_input_buffer));
  read_packet(reinterpret_cast<uint8_t*>(&m_recv_byte_output_buffer), sizeof(m_recv_byte_output_buffer));
  return m_recv_byte_output_buffer;
} 


template <typename T>
echo_out Master<T>::echo(uint32_t send) {
  // EMPTY STRUCTS STILL HAVE SIZE 1!!!!!
  m_echo_input_buffer.send = send;
  write_packet(COMMANDS::SPCMD_COMMAND_ECHO, reinterpret_cast<uint8_t*>(&m_echo_input_buffer), sizeof(m_echo_input_buffer));
  read_packet(reinterpret_cast<uint8_t*>(&m_echo_output_buffer), sizeof(m_echo_output_buffer));
  return m_echo_output_buffer;
} 


template <typename T>
bigtest_out Master<T>::bigtest(uint32_t b1, uint32_t b2) {
  // EMPTY STRUCTS STILL HAVE SIZE 1!!!!!
  m_bigtest_input_buffer.b1 = b1;
  m_bigtest_input_buffer.b2 = b2;
  write_packet(COMMANDS::SPCMD_COMMAND_BIGTEST, reinterpret_cast<uint8_t*>(&m_bigtest_input_buffer), sizeof(m_bigtest_input_buffer));
  read_packet(reinterpret_cast<uint8_t*>(&m_bigtest_output_buffer), sizeof(m_bigtest_output_buffer));
  return m_bigtest_output_buffer;
} 


} // namespace spcmds


#endif // SPACECOMMANDS_HOST_HPP
