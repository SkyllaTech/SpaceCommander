/*
 * WARNING: This file is autogenerated by SpaceCommander
 *
 * Any changes will be overwritten!
 */

#ifndef SPACECOMMANDS_SLAVE_HPP
#define SPACECOMMANDS_SLAVE_HPP

// TODO Serial library
// #include serial
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <iostream>

namespace spcmd_slave {

static const uint64_t slave_hash = 0x40419b8b99b1c6e8ull;


// Command Data Structs
struct send_byte_in {
};
struct send_byte_out {
  uint8_t b;
};
  
struct recv_byte_in {
  uint8_t b;
};
struct recv_byte_out {
};
  
struct echo_in {
  uint32_t recv;
};
struct echo_out {
  uint32_t send;
};
  
struct bigtest_in {
  uint32_t b3;
};
struct bigtest_out {
  uint32_t b1;
  uint32_t b2;
};
  

// --------------------------------------------------
/**************************************************
 * Send a byte to the slave
 *
 * Outputs:
 * Struct of type send_byte_out, which has the following
 * data members:
 * @param b Byte to be sent
 **************************************************/
send_byte_out send_byte_cb();

/**************************************************
 * Receive a byte from the slave
 *
 * Inputs:
 * @param b Received byte
 **************************************************/
recv_byte_out recv_byte_cb(uint8_t b);

/**************************************************
 * Send string to slave and read it back
 *
 * Inputs:
 * @param recv No description provided
 *
 * Outputs:
 * Struct of type echo_out, which has the following
 * data members:
 * @param send No description provided
 **************************************************/
echo_out echo_cb(uint32_t recv);

/**************************************************
 * No description provided
 *
 * Inputs:
 * @param b3 No description provided
 *
 * Outputs:
 * Struct of type bigtest_out, which has the following
 * data members:
 * @param b1 No description provided
 * @param b2 No description provided
 **************************************************/
bigtest_out bigtest_cb(uint32_t b3);

  
// Callbacks
// --------------------------------------------------
// void pre_write_cb();
// void post_write_cb();
// void pre_read_cb();
// void post_read_cb();
// Commands


enum COMMANDS : uint8_t {
    SPCMD_HEARTBEAT = 0,
    SPCMD_HASH = 1,
    SPCMD_COMMAND_SEND_BYTE = 2,
    SPCMD_COMMAND_RECV_BYTE = 3,
    SPCMD_COMMAND_ECHO = 4,
    SPCMD_COMMAND_BIGTEST = 5,
};

template <typename T>
class Slave {
public:

  Slave() {}
  Slave(T& serial);

  // User functions
  // --------------------------------------------------
  void begin();
  void close();
  bool update();

protected:
  struct write_buffer_t{
    uint8_t data[8];
  };
  struct read_buffer_t {
    uint8_t data[8];
  };
  // Internal functions
  // --------------------------------------------------
  void write_packet(const uint8_t* bytes, const size_t len);
  void read_packet(uint8_t* bytes, const size_t len);
  void hash_command();

  void send_byte();
  void recv_byte();
  void echo();
  void bigtest();
  
private:
  T* m_serial;
  write_buffer_t m_write_buffer;
  read_buffer_t m_read_buffer;
  send_byte_in m_send_byte_input_buffer;
  send_byte_out m_send_byte_output_buffer;
  recv_byte_in m_recv_byte_input_buffer;
  recv_byte_out m_recv_byte_output_buffer;
  echo_in m_echo_input_buffer;
  echo_out m_echo_output_buffer;
  bigtest_in m_bigtest_input_buffer;
  bigtest_out m_bigtest_output_buffer;
};


// Internal functions
// --------------------------------------------------
template <typename T>
Slave<T>::Slave(T& serial)
    : m_serial(&serial) {
}

template <typename T>
void Slave<T>::write_packet(const uint8_t* bytes, const size_t len) {
  memcpy(m_write_buffer.data, bytes, len);
  // Implement with proper serial code
  std::cout << "Write: ";
  for (size_t i=0; i < len; ++i) {
    std::cout << " (" << int(m_write_buffer.data[i]) << ')';
  }
  std::cout << std::endl;
}

template <typename T>
void Slave<T>::read_packet(uint8_t* bytes, const size_t len) {
  // Implement with proper serial code
  if (len == 1) {
    uint8_t a = 'a';
    memcpy(bytes, &a, 1);
  }
  if (len == 4) {
    uint32_t b = 0;
    b |= 1 << 24;
    b |= 2 << 16;
    b |= 3 << 8;
    b |= 4;
    memcpy(bytes, &b, 4);
  }
}

template <typename T>
void Slave<T>::hash_command() {
  write_packet(reinterpret_cast<const uint8_t*>(&slave_hash), 8);
}

template <typename T>
bool Slave<T>::update() {
  //if (Serial.available() > 0) {
  // Replace with serial read
  static uint8_t i = 0;
  COMMANDS command = static_cast<COMMANDS>(i);
  ++i;
  // Switch to function table lookup
  switch(command) {
  case COMMANDS::SPCMD_HEARTBEAT:
    //heartbeat();
    break;
  case COMMANDS::SPCMD_HASH:
    hash_command();
    break;
  case COMMANDS::SPCMD_COMMAND_SEND_BYTE:
    send_byte();
    break;
  case COMMANDS::SPCMD_COMMAND_RECV_BYTE:
    recv_byte();
    break;
  case COMMANDS::SPCMD_COMMAND_ECHO:
    echo();
    break;
  case COMMANDS::SPCMD_COMMAND_BIGTEST:
    bigtest();
    break;
  default:
    return false;
  }
  return true;
}


template <typename T>
void Slave<T>::send_byte() {
  read_packet(reinterpret_cast<uint8_t*>(&m_send_byte_input_buffer), sizeof(m_send_byte_input_buffer));
  m_send_byte_output_buffer = send_byte_cb();
  write_packet(reinterpret_cast<uint8_t*>(&m_send_byte_output_buffer), sizeof(m_send_byte_output_buffer));
}

template <typename T>
void Slave<T>::recv_byte() {
  read_packet(reinterpret_cast<uint8_t*>(&m_recv_byte_input_buffer), sizeof(m_recv_byte_input_buffer));
  m_recv_byte_output_buffer = recv_byte_cb(m_recv_byte_input_buffer.b);
  write_packet(reinterpret_cast<uint8_t*>(&m_recv_byte_output_buffer), sizeof(m_recv_byte_output_buffer));
}

template <typename T>
void Slave<T>::echo() {
  read_packet(reinterpret_cast<uint8_t*>(&m_echo_input_buffer), sizeof(m_echo_input_buffer));
  m_echo_output_buffer = echo_cb(m_echo_input_buffer.recv);
  write_packet(reinterpret_cast<uint8_t*>(&m_echo_output_buffer), sizeof(m_echo_output_buffer));
}

template <typename T>
void Slave<T>::bigtest() {
  read_packet(reinterpret_cast<uint8_t*>(&m_bigtest_input_buffer), sizeof(m_bigtest_input_buffer));
  m_bigtest_output_buffer = bigtest_cb(m_bigtest_input_buffer.b3);
  write_packet(reinterpret_cast<uint8_t*>(&m_bigtest_output_buffer), sizeof(m_bigtest_output_buffer));
}


} // namespace spcmds

#endif // SPACECOMMANDS_HPP
