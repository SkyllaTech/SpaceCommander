/*
 * WARNING: This file is autogenerated by SpaceCommander
 *
 * Any changes will be overwritten!
 */

#ifndef SPACECOMMANDS_SLAVE_HPP
#define SPACECOMMANDS_SLAVE_HPP

#include <Arduino.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

namespace spcmd_slave {

template<typename T> constexpr
T const c_max(T const a) {
  return a;
}

template<typename T> constexpr
T const c_max(T const a, T const b) {
  return a > b ? a : b;
}

template<typename T, typename... Args> constexpr
T const c_max(T const a, T const b, Args... args) {
  return a > b ? c_max(a, args...) : c_max(b, args...);
}

static const uint64_t slave_hash = 0xdfdf2feba025bd44ULL;
using command_type = uint8_t;
using ack_type = uint8_t;

// Automatically generated CRC function
// polynomial: 0x18005, bit reverse algorithm
uint16_t
crc_func(uint8_t *data, int16_t len, uint16_t crc)
{
    static const uint16_t table[256] = {
    0x0000U,0xC0C1U,0xC181U,0x0140U,0xC301U,0x03C0U,0x0280U,0xC241U,
    0xC601U,0x06C0U,0x0780U,0xC741U,0x0500U,0xC5C1U,0xC481U,0x0440U,
    0xCC01U,0x0CC0U,0x0D80U,0xCD41U,0x0F00U,0xCFC1U,0xCE81U,0x0E40U,
    0x0A00U,0xCAC1U,0xCB81U,0x0B40U,0xC901U,0x09C0U,0x0880U,0xC841U,
    0xD801U,0x18C0U,0x1980U,0xD941U,0x1B00U,0xDBC1U,0xDA81U,0x1A40U,
    0x1E00U,0xDEC1U,0xDF81U,0x1F40U,0xDD01U,0x1DC0U,0x1C80U,0xDC41U,
    0x1400U,0xD4C1U,0xD581U,0x1540U,0xD701U,0x17C0U,0x1680U,0xD641U,
    0xD201U,0x12C0U,0x1380U,0xD341U,0x1100U,0xD1C1U,0xD081U,0x1040U,
    0xF001U,0x30C0U,0x3180U,0xF141U,0x3300U,0xF3C1U,0xF281U,0x3240U,
    0x3600U,0xF6C1U,0xF781U,0x3740U,0xF501U,0x35C0U,0x3480U,0xF441U,
    0x3C00U,0xFCC1U,0xFD81U,0x3D40U,0xFF01U,0x3FC0U,0x3E80U,0xFE41U,
    0xFA01U,0x3AC0U,0x3B80U,0xFB41U,0x3900U,0xF9C1U,0xF881U,0x3840U,
    0x2800U,0xE8C1U,0xE981U,0x2940U,0xEB01U,0x2BC0U,0x2A80U,0xEA41U,
    0xEE01U,0x2EC0U,0x2F80U,0xEF41U,0x2D00U,0xEDC1U,0xEC81U,0x2C40U,
    0xE401U,0x24C0U,0x2580U,0xE541U,0x2700U,0xE7C1U,0xE681U,0x2640U,
    0x2200U,0xE2C1U,0xE381U,0x2340U,0xE101U,0x21C0U,0x2080U,0xE041U,
    0xA001U,0x60C0U,0x6180U,0xA141U,0x6300U,0xA3C1U,0xA281U,0x6240U,
    0x6600U,0xA6C1U,0xA781U,0x6740U,0xA501U,0x65C0U,0x6480U,0xA441U,
    0x6C00U,0xACC1U,0xAD81U,0x6D40U,0xAF01U,0x6FC0U,0x6E80U,0xAE41U,
    0xAA01U,0x6AC0U,0x6B80U,0xAB41U,0x6900U,0xA9C1U,0xA881U,0x6840U,
    0x7800U,0xB8C1U,0xB981U,0x7940U,0xBB01U,0x7BC0U,0x7A80U,0xBA41U,
    0xBE01U,0x7EC0U,0x7F80U,0xBF41U,0x7D00U,0xBDC1U,0xBC81U,0x7C40U,
    0xB401U,0x74C0U,0x7580U,0xB541U,0x7700U,0xB7C1U,0xB681U,0x7640U,
    0x7200U,0xB2C1U,0xB381U,0x7340U,0xB101U,0x71C0U,0x7080U,0xB041U,
    0x5000U,0x90C1U,0x9181U,0x5140U,0x9301U,0x53C0U,0x5280U,0x9241U,
    0x9601U,0x56C0U,0x5780U,0x9741U,0x5500U,0x95C1U,0x9481U,0x5440U,
    0x9C01U,0x5CC0U,0x5D80U,0x9D41U,0x5F00U,0x9FC1U,0x9E81U,0x5E40U,
    0x5A00U,0x9AC1U,0x9B81U,0x5B40U,0x9901U,0x59C0U,0x5880U,0x9841U,
    0x8801U,0x48C0U,0x4980U,0x8941U,0x4B00U,0x8BC1U,0x8A81U,0x4A40U,
    0x4E00U,0x8EC1U,0x8F81U,0x4F40U,0x8D01U,0x4DC0U,0x4C80U,0x8C41U,
    0x4400U,0x84C1U,0x8581U,0x4540U,0x8701U,0x47C0U,0x4680U,0x8641U,
    0x8201U,0x42C0U,0x4380U,0x8341U,0x4100U,0x81C1U,0x8081U,0x4040U,
    };
    
    while (len > 0)
    {
        crc = table[*data ^ (uint8_t)crc] ^ (crc >> 8);
        data++;
        len--;
    }
    return crc;
}


// Command Data Structs
struct send_byte_in {
  uint8_t b;
} __attribute__((packed));
struct send_byte_out {
} __attribute__((packed));
  
struct recv_byte_in {
} __attribute__((packed));
struct recv_byte_out {
  uint8_t b;
} __attribute__((packed));
  
struct echo_in {
  char send_string;
} __attribute__((packed));
struct echo_out {
  char recv_string;
} __attribute__((packed));
  

struct hash_in {
};
struct hash_out {
  uint64_t hash;
};

static const size_t max_data_size = c_max(
                                          sizeof(send_byte_in), sizeof(send_byte_out),
                                          sizeof(recv_byte_in), sizeof(recv_byte_out),
                                          sizeof(echo_in), sizeof(echo_out),
                                          sizeof(hash_in), sizeof(hash_out)
                                          );

// --------------------------------------------------
/**************************************************
 * Send a byte to the slave
 *
 * Inputs:
 * @param b Byte to be sent
 **************************************************/
send_byte_out send_byte_cb(uint8_t b);

/**************************************************
 * Receive a byte from the slave
 *
 * Outputs:
 * Struct of type recv_byte_out, which has the following
 * data members:
 * @param b Received byte
 **************************************************/
recv_byte_out recv_byte_cb();

/**************************************************
 * Send string to slave and read it back
 *
 * Inputs:
 * @param send_string No description provided
 *
 * Outputs:
 * Struct of type echo_out, which has the following
 * data members:
 * @param recv_string No description provided
 **************************************************/
echo_out echo_cb(char send_string);

  
// Callbacks
// --------------------------------------------------
void pre_write_cb();
void post_write_cb();
void pre_read_cb();
void post_read_cb();
void command_error_cb();
void read_size_fail_cb();
void read_crc_fail_cb();

// Commands

enum COMMANDS : command_type {
    SPCMD_HASH = 0,
    SPCMD_COMMAND_SEND_BYTE = 1,
    SPCMD_COMMAND_RECV_BYTE = 2,
    SPCMD_COMMAND_ECHO = 3,
};

template <typename T>
class Slave {
public:

  Slave() {}
  Slave(T& serial, uint8_t address);

  // User functions
  // --------------------------------------------------
  void begin();
  void close();
  bool update();

protected:
  struct write_buffer_t{
    uint8_t address;
    ack_type ack;
    uint8_t data[max_data_size];
    uint16_t crc;
  } __attribute__((packed));
  struct read_buffer_t {
    uint8_t address;
    COMMANDS command;
    uint8_t data[max_data_size];
    uint16_t crc;
  } __attribute__((packed));
  // Internal functions
  // --------------------------------------------------
  void write_packet(const bool ack, const size_t len);
  bool read_packet(const COMMANDS command, const size_t len);
  void hash_command();

  void send_byte();
  void recv_byte();
  void echo();
  
private:
  T* m_serial;
  write_buffer_t m_write_buffer;
  read_buffer_t m_read_buffer;
  uint8_t m_address;
};

// User functions
// --------------------------------------------------
template <typename T>
Slave<T>::Slave(T& serial, uint8_t address)
  : m_serial(&serial), m_address(address) {
  m_serial->setTimeout(1000);
  m_write_buffer.address = m_address;
  m_read_buffer.address = m_address;
}

template <typename T>
void Slave<T>::begin(){
  m_serial->begin(9600);
}
  
template <typename T>
void Slave<T>::close(){
  m_serial->end();
} 
  
template <typename T>
bool Slave<T>::update() {
  if (m_serial->available() > 0) {
    uint8_t address;
    m_serial->readBytes(&address, sizeof(address));
    if (address != m_address) {
      // Wait until we stop receiving bytes to start reading again
      delay(2 * 8 * 1000 / 9600);
      while (m_serial->available() > 0) {
        // Dump input buffer
        while (m_serial->available() > 0) {
          m_serial->read();
        }
        delay(2 * 8 * 1000 / 9600);
      }
      return true;
    }
    COMMANDS command;
    m_serial->readBytes(reinterpret_cast<uint8_t*>(&command), sizeof(command));
    // Place command into buffer
    m_read_buffer.command = command;
    // Switch to function table lookup
    switch(command) {
    case COMMANDS::SPCMD_HASH:
      hash_command();
      break;
    case COMMANDS::SPCMD_COMMAND_SEND_BYTE:
      send_byte();
      break;
    case COMMANDS::SPCMD_COMMAND_RECV_BYTE:
      recv_byte();
      break;
    case COMMANDS::SPCMD_COMMAND_ECHO:
      echo();
      break;
    default:
      return false;
    }
  }
  return true;
}

// Internal functions
// --------------------------------------------------
template <typename T>
void Slave<T>::write_packet(const bool ack, const size_t len) {
  // Pre write callback
  pre_write_cb();

  // Write ack into buffer
  m_write_buffer.ack = static_cast<ack_type>(ack);
  // Calculate CRC
  m_write_buffer.crc = crc_func(reinterpret_cast<uint8_t*>(&m_write_buffer), sizeof(uint8_t) + sizeof(ack) + len, 0);
  // Write data
  m_serial->write(reinterpret_cast<const uint8_t*>(&m_write_buffer), sizeof(uint8_t) + sizeof(ack) + len);
  // Write crc
  m_serial->write(reinterpret_cast<const uint8_t*>(&(m_write_buffer.crc)), sizeof(m_write_buffer.crc));
  m_serial->flush();
  // Post write callback
  post_write_cb();
}

template <typename T>
bool Slave<T>::read_packet(const size_t len) {
  // Pre read callback
  pre_read_cb();

  // Read from serial
  size_t read_bytes = m_serial->readBytes(reinterpret_cast<uint8_t*>(&(m_read_buffer.data)), len);
  // Read failed either due to timeout or transmission error
  if (read_bytes != len) {
    read_size_fail_cb();
    return false;
  }
  // Read CRC
  read_bytes = m_serial->readBytes(reinterpret_cast<uint8_t*>(&(m_read_buffer.crc)), sizeof(m_read_buffer.crc));
  if (read_bytes != sizeof(m_read_buffer.crc)) {
    read_size_fail_cb();
    return false;
  }
  // Test CRC
  uint16_t calc_crc = crc_func(reinterpret_cast<uint8_t*>(&m_read_buffer), sizeof(uint8_t) + sizeof(m_read_buffer.command) + len, 0);
  if (m_read_buffer.crc != calc_crc) {
    read_crc_fail_cb();
    return false;
  }
  // Post read callback
  post_read_cb();
  return true;
}

template <typename T>
void Slave<T>::hash_command() {
  bool read_success = read_packet(0);
  if (read_success) {
    memcpy(m_write_buffer.data, &slave_hash, sizeof(slave_hash));
    write_packet(true, sizeof(slave_hash));
  }
  else {
    write_packet(false, 0);
  }
}

template <typename T>
void Slave<T>::send_byte() {
  bool read_success = read_packet(sizeof(send_byte_in));
  if (read_success) {
    send_byte_in* input_buffer = reinterpret_cast<send_byte_in*>(&(m_read_buffer.data));
    send_byte_out output_buffer = send_byte_cb(input_buffer->b);

    write_packet(true, 0);
  }
  else {
    write_packet(false, 0);
  }
}

template <typename T>
void Slave<T>::recv_byte() {
  bool read_success = read_packet(0);
  if (read_success) {
    recv_byte_in* input_buffer = reinterpret_cast<recv_byte_in*>(&(m_read_buffer.data));
    recv_byte_out output_buffer = recv_byte_cb();

    memcpy(m_write_buffer.data, &output_buffer, sizeof(output_buffer));
    write_packet(true, sizeof(output_buffer));
  }
  else {
    write_packet(false, 0);
  }
}

template <typename T>
void Slave<T>::echo() {
  bool read_success = read_packet(sizeof(echo_in));
  if (read_success) {
    echo_in* input_buffer = reinterpret_cast<echo_in*>(&(m_read_buffer.data));
    echo_out output_buffer = echo_cb(input_buffer->send_string);

    memcpy(m_write_buffer.data, &output_buffer, sizeof(output_buffer));
    write_packet(true, sizeof(output_buffer));
  }
  else {
    write_packet(false, 0);
  }
}


} // namespace spcmds

#endif // SPACECOMMANDS_HPP
